// Generated by rstantools.  Do not edit by hand.

// [[Rcpp::depends(StanHeaders)]]
// [[Rcpp::depends(rstan)]]
// [[Rcpp::plugins(rstan)]]
// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::depends(BH)]]
#include <stan/math/prim/fun/Eigen.hpp>
#include <stan/math/prim/meta.hpp>
#include <boost/integer/integer_log2.hpp>
#include <RcppEigen.h>
#ifndef USE_STANC3
#define USE_STANC3
#endif
// Code generated by stanc v2.32.2
#include <stan/model/model_header.hpp>
namespace modeld909191fa320_User_defined_functions_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 115> locations_array__ =
  {" (found before start of program)",
  " (in 'User-defined functions', line 29, column 4 to column 13)",
  " (in 'User-defined functions', line 28, column 9 to line 30, column 3)",
  " (in 'User-defined functions', line 27, column 4 to column 13)",
  " (in 'User-defined functions', line 26, column 12 to line 28, column 3)",
  " (in 'User-defined functions', line 26, column 2 to line 30, column 3)",
  " (in 'User-defined functions', line 31, column 2 to column 41)",
  " (in 'User-defined functions', line 32, column 2 to column 11)",
  " (in 'User-defined functions', line 15, column 25 to line 33, column 1)",
  " (in 'User-defined functions', line 48, column 4 to column 13)",
  " (in 'User-defined functions', line 47, column 9 to line 49, column 3)",
  " (in 'User-defined functions', line 46, column 4 to column 13)",
  " (in 'User-defined functions', line 45, column 12 to line 47, column 3)",
  " (in 'User-defined functions', line 45, column 2 to line 49, column 3)",
  " (in 'User-defined functions', line 50, column 2 to column 41)",
  " (in 'User-defined functions', line 51, column 2 to column 11)",
  " (in 'User-defined functions', line 34, column 25 to line 52, column 1)",
  " (in 'User-defined functions', line 79, column 2 to column 84)",
  " (in 'User-defined functions', line 53, column 45 to line 80, column 1)",
  " (in 'User-defined functions', line 112, column 2 to column 29)",
  " (in 'User-defined functions', line 81, column 48 to line 113, column 1)",
  " (in 'User-defined functions', line 129, column 2 to column 36)",
  " (in 'User-defined functions', line 114, column 32 to line 130, column 1)",
  " (in 'User-defined functions', line 145, column 2 to column 38)",
  " (in 'User-defined functions', line 131, column 36 to line 146, column 1)",
  " (in 'User-defined functions', line 156, column 9 to column 26)",
  " (in 'User-defined functions', line 156, column 28 to column 45)",
  " (in 'User-defined functions', line 156, column 2 to column 103)",
  " (in 'User-defined functions', line 158, column 2 to column 29)",
  " (in 'User-defined functions', line 160, column 2 to column 77)",
  " (in 'User-defined functions', line 161, column 2 to column 11)",
  " (in 'User-defined functions', line 147, column 48 to line 162, column 1)",
  " (in 'User-defined functions', line 172, column 9 to column 18)",
  " (in 'User-defined functions', line 172, column 20 to column 29)",
  " (in 'User-defined functions', line 172, column 2 to column 71)",
  " (in 'User-defined functions', line 175, column 4 to column 76)",
  " (in 'User-defined functions', line 174, column 16 to line 176, column 3)",
  " (in 'User-defined functions', line 174, column 2 to line 176, column 3)",
  " (in 'User-defined functions', line 177, column 2 to column 11)",
  " (in 'User-defined functions', line 163, column 40 to line 178, column 1)",
  " (in 'User-defined functions', line 188, column 9 to column 26)",
  " (in 'User-defined functions', line 188, column 2 to column 30)",
  " (in 'User-defined functions', line 191, column 4 to column 59)",
  " (in 'User-defined functions', line 190, column 16 to line 192, column 3)",
  " (in 'User-defined functions', line 190, column 2 to line 192, column 3)",
  " (in 'User-defined functions', line 193, column 2 to column 11)",
  " (in 'User-defined functions', line 179, column 31 to line 194, column 1)",
  " (in 'User-defined functions', line 212, column 2 to column 26)",
  " (in 'User-defined functions', line 213, column 9 to column 12)",
  " (in 'User-defined functions', line 213, column 2 to column 16)",
  " (in 'User-defined functions', line 216, column 4 to column 51)",
  " (in 'User-defined functions', line 215, column 16 to line 217, column 3)",
  " (in 'User-defined functions', line 215, column 2 to line 217, column 3)",
  " (in 'User-defined functions', line 218, column 2 to column 11)",
  " (in 'User-defined functions', line 195, column 41 to line 219, column 1)",
  " (in 'User-defined functions', line 232, column 10 to column 29)",
  " (in 'User-defined functions', line 232, column 2 to column 33)",
  " (in 'User-defined functions', line 235, column 4 to column 29)",
  " (in 'User-defined functions', line 234, column 2 to line 235, column 29)",
  " (in 'User-defined functions', line 237, column 2 to column 27)",
  " (in 'User-defined functions', line 238, column 2 to column 11)",
  " (in 'User-defined functions', line 220, column 43 to line 239, column 1)",
  " (in 'User-defined functions', line 252, column 10 to column 29)",
  " (in 'User-defined functions', line 252, column 2 to column 33)",
  " (in 'User-defined functions', line 255, column 4 to column 29)",
  " (in 'User-defined functions', line 254, column 2 to line 255, column 29)",
  " (in 'User-defined functions', line 257, column 2 to column 13)",
  " (in 'User-defined functions', line 258, column 2 to column 11)",
  " (in 'User-defined functions', line 240, column 43 to line 259, column 1)",
  " (in 'User-defined functions', line 271, column 9 to column 24)",
  " (in 'User-defined functions', line 271, column 2 to column 28)",
  " (in 'User-defined functions', line 273, column 4 to column 51)",
  " (in 'User-defined functions', line 272, column 2 to line 273, column 51)",
  " (in 'User-defined functions', line 274, column 2 to column 11)",
  " (in 'User-defined functions', line 260, column 34 to line 275, column 1)",
  " (in 'User-defined functions', line 287, column 2 to column 31)",
  " (in 'User-defined functions', line 276, column 34 to line 288, column 1)",
  " (in 'User-defined functions', line 313, column 2 to column 36)",
  " (in 'User-defined functions', line 315, column 9 to column 14)",
  " (in 'User-defined functions', line 315, column 16 to column 29)",
  " (in 'User-defined functions', line 315, column 2 to column 54)",
  " (in 'User-defined functions', line 316, column 9 to column 19)",
  " (in 'User-defined functions', line 316, column 21 to column 35)",
  " (in 'User-defined functions', line 316, column 2 to column 60)",
  " (in 'User-defined functions', line 317, column 9 to column 17)",
  " (in 'User-defined functions', line 317, column 2 to column 55)",
  " (in 'User-defined functions', line 318, column 9 to column 17)",
  " (in 'User-defined functions', line 318, column 2 to column 61)",
  " (in 'User-defined functions', line 319, column 9 to column 17)",
  " (in 'User-defined functions', line 319, column 2 to column 55)",
  " (in 'User-defined functions', line 321, column 9 to column 14)",
  " (in 'User-defined functions', line 321, column 16 to column 25)",
  " (in 'User-defined functions', line 321, column 2 to column 65)",
  " (in 'User-defined functions', line 322, column 9 to column 14)",
  " (in 'User-defined functions', line 322, column 16 to column 25)",
  " (in 'User-defined functions', line 322, column 2 to column 66)",
  " (in 'User-defined functions', line 323, column 9 to column 19)",
  " (in 'User-defined functions', line 323, column 21 to column 31)",
  " (in 'User-defined functions', line 323, column 2 to column 78)",
  " (in 'User-defined functions', line 325, column 2 to column 19)",
  " (in 'User-defined functions', line 326, column 2 to column 19)",
  " (in 'User-defined functions', line 331, column 6 to column 82)",
  " (in 'User-defined functions', line 329, column 33 to line 332, column 5)",
  " (in 'User-defined functions', line 329, column 4 to line 332, column 5)",
  " (in 'User-defined functions', line 328, column 21 to line 333, column 3)",
  " (in 'User-defined functions', line 328, column 2 to line 333, column 3)",
  " (in 'User-defined functions', line 338, column 6 to column 45)",
  " (in 'User-defined functions', line 340, column 6 to column 121)",
  " (in 'User-defined functions', line 336, column 32 to line 341, column 5)",
  " (in 'User-defined functions', line 336, column 4 to line 341, column 5)",
  " (in 'User-defined functions', line 335, column 20 to line 342, column 3)",
  " (in 'User-defined functions', line 335, column 2 to line 342, column 3)",
  " (in 'User-defined functions', line 344, column 2 to column 57)",
  " (in 'User-defined functions', line 345, column 2 to column 11)",
  " (in 'User-defined functions', line 302, column 3 to line 346, column 1)"};
int max_int(const int& a, const int& b, std::ostream* pstream__);
int min_int(const int& a, const int& b, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,1>
AR(const T0__& y_arg__, const T1__& phi_arg__, const int& t, const int& p,
   std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,1>
MA(const T0__& xi_arg__, const T1__& theta_arg__, const int& t, const int& q,
   std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_phi_AR(const T0__& phi_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_theta_MA(const T0__& theta_arg__, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,-1>
create_block_diagonal(const T0__& A_arg__, const T1__& B_arg__, std::ostream*
                      pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
rep_diagonal_mat(const T0__& A_arg__, const int& k, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec(const T0__& A_arg__, const int& k, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec_piecewise(const T0__& A_arg__, const int& k, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_stan_scalar<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>, T1__>,-1,1>
append_val_2_vec(const T0__& A_arg__, const T1__& val, std::ostream*
                 pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>>,-1,1>
append_vec_2_val(const T0__& val, const T1__& A_arg__, std::ostream*
                 pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rowwise_mat_2_vec(const T0__& A_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
colwise_mat_2_vec(const T0__& A_arg__, std::ostream* pstream__);
template <typename T3__, typename T4__, typename T5__, typename T6__,
          typename T7__, typename T11__, typename T12__, typename T13__,
          typename T14__, typename T15__, typename T16__,
          stan::require_all_t<stan::is_col_vector<T3__>,
                              stan::is_vt_not_complex<T3__>,
                              stan::is_col_vector<T4__>,
                              stan::is_vt_not_complex<T4__>,
                              stan::is_col_vector<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_col_vector<T7__>,
                              stan::is_vt_not_complex<T7__>,
                              stan::is_col_vector<T11__>,
                              stan::is_vt_not_complex<T11__>,
                              stan::is_col_vector<T12__>,
                              stan::is_vt_not_complex<T12__>,
                              stan::is_stan_scalar<T13__>,
                              stan::is_stan_scalar<T14__>,
                              stan::is_eigen_matrix_dynamic<T15__>,
                              stan::is_vt_not_complex<T15__>,
                              stan::is_eigen_matrix_dynamic<T16__>,
                              stan::is_vt_not_complex<T16__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T3__>,
                stan::base_type_t<T4__>, stan::base_type_t<T5__>,
                stan::base_type_t<T6__>, stan::base_type_t<T7__>,
                stan::promote_args_t<stan::base_type_t<T11__>,
                  stan::base_type_t<T12__>, T13__, T14__,
                  stan::base_type_t<T15__>,
                  stan::promote_args_t<stan::base_type_t<T16__>>>>,-1,-1>
state_space_model(const int& num_steps, const int& num_delays, const int&
                  num_strata, const T3__& phi_mu_arg__, const T4__&
                  theta_mu_arg__, const T5__& phi_nu_arg__, const T6__&
                  mu_intercept_arg__, const T7__& nu_intercept_arg__,
                  const int& mu_p, const int& mu_q, const int& nu_p,
                  const T11__& mu_init_arg__, const T12__& nu_init_arg__,
                  const T13__& sd_mu, const T14__& sd_nu, const T15__&
                  xi_mu_arg__, const T16__& xi_nu_arg__, std::ostream*
                  pstream__);
int max_int(const int& a, const int& b, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 5;
    if (stan::math::logical_gt(a, b)) {
      current_statement__ = 3;
      return a;
    } else {
      current_statement__ = 1;
      return b;
    }
    current_statement__ = 6;
    std::stringstream errmsg_stream__;
    stan::math::stan_print(&errmsg_stream__, "Error in `max_int` function.");
    throw std::domain_error(errmsg_stream__.str());
    current_statement__ = 7;
    return 1;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int min_int(const int& a, const int& b, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 13;
    if (stan::math::logical_gt(a, b)) {
      current_statement__ = 11;
      return b;
    } else {
      current_statement__ = 9;
      return a;
    }
    current_statement__ = 14;
    std::stringstream errmsg_stream__;
    stan::math::stan_print(&errmsg_stream__, "Error in `min_int` function.");
    throw std::domain_error(errmsg_stream__.str());
    current_statement__ = 15;
    return 1;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,1>
AR(const T0__& y_arg__, const T1__& phi_arg__, const int& t, const int& p,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  const auto& y = stan::math::to_ref(y_arg__);
  const auto& phi = stan::math::to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 17;
    return stan::math::multiply(
             stan::model::rvalue(y, "y", stan::model::index_omni(),
               stan::model::index_min_max(((t + 1) -
                 min_int(t, (p + 1), pstream__)), t)),
             stan::model::rvalue(phi, "phi",
               stan::model::index_min_max(((p + 2) -
                 min_int(t, (p + 1), pstream__)), (p + 1))));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,1>
MA(const T0__& xi_arg__, const T1__& theta_arg__, const int& t, const int& q,
   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  const auto& xi = stan::math::to_ref(xi_arg__);
  const auto& theta = stan::math::to_ref(theta_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 19;
    return AR(xi, theta, t, q, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_phi_AR(const T0__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& phi = stan::math::to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 21;
    return append_val_2_vec(phi, 0.0, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_theta_MA(const T0__& theta_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& theta = stan::math::to_ref(theta_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 23;
    return append_val_2_vec(theta, 1.0, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,-1>
create_block_diagonal(const T0__& A_arg__, const T1__& B_arg__, std::ostream*
                      pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  const auto& B = stan::math::to_ref(B_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 25;
    stan::math::validate_non_negative_index("C", "rows(A) + rows(B)",
      (stan::math::rows(A) + stan::math::rows(B)));
    current_statement__ = 26;
    stan::math::validate_non_negative_index("C", "cols(A) + cols(B)",
      (stan::math::cols(A) + stan::math::cols(B)));
    Eigen::Matrix<local_scalar_t__,-1,-1> C =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant((stan::math::rows(A) +
        stan::math::rows(B)), (stan::math::cols(A) + stan::math::cols(B)),
        DUMMY_VAR__);
    current_statement__ = 27;
    stan::model::assign(C,
      stan::math::rep_matrix(0, (stan::math::rows(A) + stan::math::rows(B)),
        (stan::math::cols(A) + stan::math::cols(B))), "assigning variable C");
    current_statement__ = 28;
    stan::model::assign(C, A, "assigning variable C",
      stan::model::index_min_max(1, stan::math::rows(A)),
      stan::model::index_min_max(1, stan::math::cols(A)));
    current_statement__ = 29;
    stan::model::assign(C, B, "assigning variable C",
      stan::model::index_min_max((stan::math::rows(A) + 1),
        (stan::math::rows(A) + stan::math::rows(B))),
      stan::model::index_min_max((stan::math::cols(A) + 1),
        (stan::math::cols(A) + stan::math::cols(B))));
    current_statement__ = 30;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
rep_diagonal_mat(const T0__& A_arg__, const int& k, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 32;
    stan::math::validate_non_negative_index("C", "rows(A) * k",
      (stan::math::rows(A) * k));
    current_statement__ = 33;
    stan::math::validate_non_negative_index("C", "cols(A) * k",
      (stan::math::cols(A) * k));
    Eigen::Matrix<local_scalar_t__,-1,-1> C =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant((stan::math::rows(A) *
        k), (stan::math::cols(A) * k), DUMMY_VAR__);
    current_statement__ = 34;
    stan::model::assign(C,
      stan::math::rep_matrix(0, (stan::math::rows(A) * k),
        (stan::math::cols(A) * k)), "assigning variable C");
    current_statement__ = 37;
    for (int l = 1; l <= k; ++l) {
      current_statement__ = 35;
      stan::model::assign(C, A, "assigning variable C",
        stan::model::index_min_max((((l - 1) * stan::math::rows(A)) + 1), (l
          * stan::math::rows(A))),
        stan::model::index_min_max((((l - 1) * stan::math::cols(A)) + 1), (l
          * stan::math::cols(A))));
    }
    current_statement__ = 38;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec(const T0__& A_arg__, const int& k, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 40;
    stan::math::validate_non_negative_index("C", "num_elements(A) * k",
      (stan::math::num_elements(A) * k));
    Eigen::Matrix<local_scalar_t__,-1,1> C =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((stan::math::num_elements(
                                                        A) * k), DUMMY_VAR__);
    current_statement__ = 44;
    for (int l = 1; l <= k; ++l) {
      current_statement__ = 42;
      stan::model::assign(C, A, "assigning variable C",
        stan::model::index_min_max((((l - 1) * stan::math::num_elements(A)) +
          1), (l * stan::math::num_elements(A))));
    }
    current_statement__ = 45;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec_piecewise(const T0__& A_arg__, const int& k, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int n = std::numeric_limits<int>::min();
    current_statement__ = 47;
    n = stan::math::num_elements(A);
    current_statement__ = 48;
    stan::math::validate_non_negative_index("C", "n * k", (n * k));
    Eigen::Matrix<local_scalar_t__,-1,1> C =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((n * k), DUMMY_VAR__);
    current_statement__ = 52;
    for (int j = 1; j <= n; ++j) {
      current_statement__ = 50;
      stan::model::assign(C,
        stan::math::rep_vector(
          stan::model::rvalue(A, "A", stan::model::index_uni(j)), k),
        "assigning variable C",
        stan::model::index_min_max((((j - 1) * k) + 1), (k * j)));
    }
    current_statement__ = 53;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_stan_scalar<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>, T1__>,-1,1>
append_val_2_vec(const T0__& A_arg__, const T1__& val, std::ostream*
                 pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             T1__>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 55;
    stan::math::validate_non_negative_index("B", "num_elements(A) + 1",
      (stan::math::num_elements(A) + 1));
    Eigen::Matrix<local_scalar_t__,-1,1> B =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((stan::math::num_elements(
                                                        A) + 1), DUMMY_VAR__);
    current_statement__ = 58;
    if (stan::math::logical_gt(stan::math::num_elements(A), 0)) {
      current_statement__ = 57;
      stan::model::assign(B, A, "assigning variable B",
        stan::model::index_min_max(1, stan::math::num_elements(A)));
    }
    current_statement__ = 59;
    stan::model::assign(B, val, "assigning variable B",
      stan::model::index_uni(stan::math::num_elements(B)));
    current_statement__ = 60;
    return B;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>>,-1,1>
append_vec_2_val(const T0__& val, const T1__& A_arg__, std::ostream*
                 pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 62;
    stan::math::validate_non_negative_index("B", "num_elements(A) + 1",
      (stan::math::num_elements(A) + 1));
    Eigen::Matrix<local_scalar_t__,-1,1> B =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((stan::math::num_elements(
                                                        A) + 1), DUMMY_VAR__);
    current_statement__ = 65;
    if (stan::math::logical_gt(stan::math::num_elements(A), 0)) {
      current_statement__ = 64;
      stan::model::assign(B, A, "assigning variable B",
        stan::model::index_min_max(2, stan::math::num_elements(B)));
    }
    current_statement__ = 66;
    stan::model::assign(B, val, "assigning variable B",
      stan::model::index_uni(1));
    current_statement__ = 67;
    return B;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rowwise_mat_2_vec(const T0__& A_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 69;
    stan::math::validate_non_negative_index("B", "num_elements(A)",
      stan::math::num_elements(A));
    Eigen::Matrix<local_scalar_t__,-1,1> B =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(stan::math::num_elements(
                                                       A), DUMMY_VAR__);
    current_statement__ = 72;
    for (int d = 1; d <= stan::math::rows(A); ++d) {
      current_statement__ = 71;
      stan::model::assign(B,
        stan::math::transpose(
          stan::model::rvalue(A, "A", stan::model::index_uni(d),
            stan::model::index_omni())), "assigning variable B",
        stan::model::index_min_max(((stan::math::cols(A) * (d - 1)) + 1),
          (stan::math::cols(A) * d)));
    }
    current_statement__ = 73;
    return B;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
colwise_mat_2_vec(const T0__& A_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 75;
    return rowwise_mat_2_vec(stan::math::transpose(A), pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T3__, typename T4__, typename T5__, typename T6__,
          typename T7__, typename T11__, typename T12__, typename T13__,
          typename T14__, typename T15__, typename T16__,
          stan::require_all_t<stan::is_col_vector<T3__>,
                              stan::is_vt_not_complex<T3__>,
                              stan::is_col_vector<T4__>,
                              stan::is_vt_not_complex<T4__>,
                              stan::is_col_vector<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_col_vector<T7__>,
                              stan::is_vt_not_complex<T7__>,
                              stan::is_col_vector<T11__>,
                              stan::is_vt_not_complex<T11__>,
                              stan::is_col_vector<T12__>,
                              stan::is_vt_not_complex<T12__>,
                              stan::is_stan_scalar<T13__>,
                              stan::is_stan_scalar<T14__>,
                              stan::is_eigen_matrix_dynamic<T15__>,
                              stan::is_vt_not_complex<T15__>,
                              stan::is_eigen_matrix_dynamic<T16__>,
                              stan::is_vt_not_complex<T16__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T3__>,
                stan::base_type_t<T4__>, stan::base_type_t<T5__>,
                stan::base_type_t<T6__>, stan::base_type_t<T7__>,
                stan::promote_args_t<stan::base_type_t<T11__>,
                  stan::base_type_t<T12__>, T13__, T14__,
                  stan::base_type_t<T15__>,
                  stan::promote_args_t<stan::base_type_t<T16__>>>>,-1,-1>
state_space_model(const int& num_steps, const int& num_delays, const int&
                  num_strata, const T3__& phi_mu_arg__, const T4__&
                  theta_mu_arg__, const T5__& phi_nu_arg__, const T6__&
                  mu_intercept_arg__, const T7__& nu_intercept_arg__,
                  const int& mu_p, const int& mu_q, const int& nu_p,
                  const T11__& mu_init_arg__, const T12__& nu_init_arg__,
                  const T13__& sd_mu, const T14__& sd_nu, const T15__&
                  xi_mu_arg__, const T16__& xi_nu_arg__, std::ostream*
                  pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T3__>,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T11__>,
                               stan::base_type_t<T12__>, T13__, T14__,
                               stan::base_type_t<T15__>,
                               stan::promote_args_t<stan::base_type_t<T16__>>>>;
  int current_statement__ = 0;
  const auto& phi_mu = stan::math::to_ref(phi_mu_arg__);
  const auto& theta_mu = stan::math::to_ref(theta_mu_arg__);
  const auto& phi_nu = stan::math::to_ref(phi_nu_arg__);
  const auto& mu_intercept = stan::math::to_ref(mu_intercept_arg__);
  const auto& nu_intercept = stan::math::to_ref(nu_intercept_arg__);
  const auto& mu_init = stan::math::to_ref(mu_init_arg__);
  const auto& nu_init = stan::math::to_ref(nu_init_arg__);
  const auto& xi_mu = stan::math::to_ref(xi_mu_arg__);
  const auto& xi_nu = stan::math::to_ref(xi_nu_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int tsize = std::numeric_limits<int>::min();
    current_statement__ = 77;
    tsize = (num_strata * num_delays);
    current_statement__ = 78;
    stan::math::validate_non_negative_index("error_mu", "tsize", tsize);
    current_statement__ = 79;
    stan::math::validate_non_negative_index("error_mu", "num_steps - 1",
      (num_steps - 1));
    Eigen::Matrix<local_scalar_t__,-1,-1> error_mu =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(tsize, (num_steps - 1),
        DUMMY_VAR__);
    current_statement__ = 80;
    stan::model::assign(error_mu, stan::math::multiply(sd_mu, xi_mu),
      "assigning variable error_mu");
    current_statement__ = 81;
    stan::math::validate_non_negative_index("error_nu", "num_strata",
      num_strata);
    current_statement__ = 82;
    stan::math::validate_non_negative_index("error_nu", "num_delays - 1",
      (num_delays - 1));
    Eigen::Matrix<local_scalar_t__,-1,-1> error_nu =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(num_strata, (num_delays
        - 1), DUMMY_VAR__);
    current_statement__ = 83;
    stan::model::assign(error_nu, stan::math::multiply(sd_nu, xi_nu),
      "assigning variable error_nu");
    current_statement__ = 84;
    stan::math::validate_non_negative_index("phi_mu_star", "mu_p + 1", (mu_p
      + 1));
    Eigen::Matrix<local_scalar_t__,-1,1> phi_mu_star =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((mu_p + 1), DUMMY_VAR__);
    current_statement__ = 85;
    stan::model::assign(phi_mu_star, create_phi_AR(phi_mu, pstream__),
      "assigning variable phi_mu_star");
    current_statement__ = 86;
    stan::math::validate_non_negative_index("theta_mu_star", "mu_q + 1",
      (mu_q + 1));
    Eigen::Matrix<local_scalar_t__,-1,1> theta_mu_star =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((mu_q + 1), DUMMY_VAR__);
    current_statement__ = 87;
    stan::model::assign(theta_mu_star, create_theta_MA(theta_mu, pstream__),
      "assigning variable theta_mu_star");
    current_statement__ = 88;
    stan::math::validate_non_negative_index("phi_nu_star", "nu_p + 1", (nu_p
      + 1));
    Eigen::Matrix<local_scalar_t__,-1,1> phi_nu_star =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((nu_p + 1), DUMMY_VAR__);
    current_statement__ = 89;
    stan::model::assign(phi_nu_star, create_phi_AR(phi_nu, pstream__),
      "assigning variable phi_nu_star");
    current_statement__ = 90;
    stan::math::validate_non_negative_index("m", "tsize", tsize);
    current_statement__ = 91;
    stan::math::validate_non_negative_index("m", "num_steps", num_steps);
    Eigen::Matrix<local_scalar_t__,-1,-1> m =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(tsize, num_steps,
        DUMMY_VAR__);
    current_statement__ = 92;
    stan::model::assign(m, stan::math::rep_matrix(0.0, tsize, num_steps),
      "assigning variable m");
    current_statement__ = 93;
    stan::math::validate_non_negative_index("mu", "tsize", tsize);
    current_statement__ = 94;
    stan::math::validate_non_negative_index("mu", "num_steps", num_steps);
    Eigen::Matrix<local_scalar_t__,-1,-1> mu =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(tsize, num_steps,
        DUMMY_VAR__);
    current_statement__ = 95;
    stan::model::assign(mu, stan::math::rep_matrix(0.0, tsize, num_steps),
      "assigning variable mu");
    current_statement__ = 96;
    stan::math::validate_non_negative_index("nu", "num_strata", num_strata);
    current_statement__ = 97;
    stan::math::validate_non_negative_index("nu", "num_delays", num_delays);
    Eigen::Matrix<local_scalar_t__,-1,-1> nu =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(num_strata, num_delays,
        DUMMY_VAR__);
    current_statement__ = 98;
    stan::model::assign(nu,
      stan::math::rep_matrix(0.0, num_strata, num_delays),
      "assigning variable nu");
    current_statement__ = 99;
    stan::model::assign(mu, mu_init, "assigning variable mu",
      stan::model::index_omni(), stan::model::index_uni(1));
    current_statement__ = 100;
    stan::model::assign(nu, nu_init, "assigning variable nu",
      stan::model::index_omni(), stan::model::index_uni(1));
    current_statement__ = 105;
    if (stan::math::logical_gt(num_delays, 1)) {
      current_statement__ = 103;
      for (int d = 1; d <= (num_delays - 1); ++d) {
        current_statement__ = 101;
        stan::model::assign(nu,
          stan::math::add(
            stan::math::add(nu_intercept,
              AR(stan::model::deep_copy(nu), phi_nu_star, (d + 1), nu_p,
                pstream__)),
            stan::model::rvalue(error_nu, "error_nu",
              stan::model::index_omni(), stan::model::index_uni(d))),
          "assigning variable nu", stan::model::index_omni(),
          stan::model::index_uni((d + 1)));
      }
    }
    current_statement__ = 111;
    if (stan::math::logical_gt(num_steps, 1)) {
      current_statement__ = 109;
      for (int t = 1; t <= (num_steps - 1); ++t) {
        current_statement__ = 106;
        stan::model::assign(m,
          stan::math::add(
            stan::model::rvalue(mu, "mu", stan::model::index_omni(),
              stan::model::index_uni(t)), colwise_mat_2_vec(nu, pstream__)),
          "assigning variable m", stan::model::index_omni(),
          stan::model::index_uni(t));
        current_statement__ = 107;
        stan::model::assign(mu,
          stan::math::add(
            stan::math::add(
              stan::math::add(mu_intercept,
                AR(stan::model::deep_copy(mu), phi_mu_star, (t + 1), mu_p,
                  pstream__)),
              MA(error_mu, theta_mu_star, t, mu_q, pstream__)),
            stan::model::rvalue(error_mu, "error_mu",
              stan::model::index_omni(), stan::model::index_uni(t))),
          "assigning variable mu", stan::model::index_omni(),
          stan::model::index_uni((t + 1)));
      }
    }
    current_statement__ = 112;
    stan::model::assign(m,
      stan::math::add(
        stan::model::rvalue(mu, "mu", stan::model::index_omni(),
          stan::model::index_uni(num_steps)),
        colwise_mat_2_vec(nu, pstream__)), "assigning variable m",
      stan::model::index_omni(), stan::model::index_uni(num_steps));
    current_statement__ = 113;
    return m;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
}
// [[Rcpp::export]]
 int  max_int(const int& a, const int& b, std::ostream* pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::max_int(a, b,
           pstream__);
}
// [[Rcpp::export]]
 int  min_int(const int& a, const int& b, std::ostream* pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::min_int(a, b,
           pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>,                 stan::base_type_t<double>>,-1,1> 
AR(const Eigen::Matrix<double,-1,-1>& y, const Eigen::Matrix<double,-1,1>&
   phi, const int& t, const int& p, std::ostream* pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::AR(y, phi, t, p,
           pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>,                 stan::base_type_t<double>>,-1,1> 
MA(const Eigen::Matrix<double,-1,-1>& xi, const Eigen::Matrix<double,-1,1>&
   theta, const int& t, const int& q, std::ostream* pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::MA(xi, theta, t,
           q, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,1> 
create_phi_AR(const Eigen::Matrix<double,-1,1>& phi, std::ostream*
              pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::create_phi_AR(
           phi, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,1> 
create_theta_MA(const Eigen::Matrix<double,-1,1>& theta, std::ostream*
                pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::create_theta_MA(
           theta, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>,                 stan::base_type_t<double>>,-1,-1> 
create_block_diagonal(const Eigen::Matrix<double,-1,-1>& A,
                      const Eigen::Matrix<double,-1,-1>& B, std::ostream*
                      pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::create_block_diagonal(
           A, B, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,-1> 
rep_diagonal_mat(const Eigen::Matrix<double,-1,-1>& A, const int& k,
                 std::ostream* pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::rep_diagonal_mat(
           A, k, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,1> 
rep_vec(const Eigen::Matrix<double,-1,1>& A, const int& k, std::ostream*
        pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::rep_vec(A, k,
           pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,1> 
rep_vec_piecewise(const Eigen::Matrix<double,-1,1>& A, const int& k,
                  std::ostream* pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::rep_vec_piecewise(
           A, k, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>, double>,-1,1> 
append_val_2_vec(const Eigen::Matrix<double,-1,1>& A, const double& val,
                 std::ostream* pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::append_val_2_vec(
           A, val, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<double, stan::base_type_t<double>>,-1,1> 
append_vec_2_val(const double& val, const Eigen::Matrix<double,-1,1>& A,
                 std::ostream* pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::append_vec_2_val(
           val, A, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,1> 
rowwise_mat_2_vec(const Eigen::Matrix<double,-1,-1>& A, std::ostream*
                  pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::rowwise_mat_2_vec(
           A, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,1> 
colwise_mat_2_vec(const Eigen::Matrix<double,-1,-1>& A, std::ostream*
                  pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::colwise_mat_2_vec(
           A, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>,                 stan::base_type_t<double>, stan::base_type_t<double>,                 stan::base_type_t<double>, stan::base_type_t<double>,                 stan::promote_args_t<stan::base_type_t<double>,                   stan::base_type_t<double>, double, double,                   stan::base_type_t<double>,                   stan::promote_args_t<stan::base_type_t<double>>>>,-1,-1> 
state_space_model(const int& num_steps, const int& num_delays, const int&
                  num_strata, const Eigen::Matrix<double,-1,1>& phi_mu,
                  const Eigen::Matrix<double,-1,1>& theta_mu,
                  const Eigen::Matrix<double,-1,1>& phi_nu,
                  const Eigen::Matrix<double,-1,1>& mu_intercept,
                  const Eigen::Matrix<double,-1,1>& nu_intercept, const int&
                  mu_p, const int& mu_q, const int& nu_p,
                  const Eigen::Matrix<double,-1,1>& mu_init,
                  const Eigen::Matrix<double,-1,1>& nu_init, const double&
                  sd_mu, const double& sd_nu,
                  const Eigen::Matrix<double,-1,-1>& xi_mu,
                  const Eigen::Matrix<double,-1,-1>& xi_nu, std::ostream*
                  pstream__ = 0) {
  return modeld909191fa320_User_defined_functions_namespace::state_space_model(
           num_steps, num_delays, num_strata, phi_mu, theta_mu, phi_nu,
           mu_intercept, nu_intercept, mu_p, mu_q, nu_p, mu_init, nu_init,
           sd_mu, sd_nu, xi_mu, xi_nu, pstream__);
}
