// Generated by rstantools.  Do not edit by hand.

// [[Rcpp::depends(StanHeaders)]]
// [[Rcpp::depends(rstan)]]
// [[Rcpp::plugins(rstan)]]
// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::depends(BH)]]
#include <stan/math/prim/fun/Eigen.hpp>
#include <stan/math/prim/meta.hpp>
#include <boost/integer/integer_log2.hpp>
#include <RcppEigen.h>
#ifndef USE_STANC3
#define USE_STANC3
#endif
// Code generated by stanc v2.32.2
#include <stan/model/model_header.hpp>
namespace model41f6152663de_User_defined_functions_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 168> locations_array__ =
  {" (found before start of program)",
  " (in 'User-defined functions', line 24, column 9 to column 26)",
  " (in 'User-defined functions', line 24, column 28 to column 45)",
  " (in 'User-defined functions', line 24, column 2 to column 103)",
  " (in 'User-defined functions', line 26, column 2 to column 29)",
  " (in 'User-defined functions', line 28, column 2 to column 77)",
  " (in 'User-defined functions', line 29, column 2 to column 11)",
  " (in 'User-defined functions', line 15, column 48 to line 30, column 1)",
  " (in 'User-defined functions', line 40, column 9 to column 18)",
  " (in 'User-defined functions', line 40, column 20 to column 29)",
  " (in 'User-defined functions', line 40, column 2 to column 71)",
  " (in 'User-defined functions', line 43, column 4 to column 76)",
  " (in 'User-defined functions', line 42, column 16 to line 44, column 3)",
  " (in 'User-defined functions', line 42, column 2 to line 44, column 3)",
  " (in 'User-defined functions', line 45, column 2 to column 11)",
  " (in 'User-defined functions', line 31, column 40 to line 46, column 1)",
  " (in 'User-defined functions', line 56, column 9 to column 26)",
  " (in 'User-defined functions', line 56, column 2 to column 30)",
  " (in 'User-defined functions', line 59, column 4 to column 59)",
  " (in 'User-defined functions', line 58, column 16 to line 60, column 3)",
  " (in 'User-defined functions', line 58, column 2 to line 60, column 3)",
  " (in 'User-defined functions', line 61, column 2 to column 11)",
  " (in 'User-defined functions', line 47, column 31 to line 62, column 1)",
  " (in 'User-defined functions', line 80, column 2 to column 26)",
  " (in 'User-defined functions', line 81, column 9 to column 12)",
  " (in 'User-defined functions', line 81, column 2 to column 16)",
  " (in 'User-defined functions', line 84, column 4 to column 51)",
  " (in 'User-defined functions', line 83, column 16 to line 85, column 3)",
  " (in 'User-defined functions', line 83, column 2 to line 85, column 3)",
  " (in 'User-defined functions', line 86, column 2 to column 11)",
  " (in 'User-defined functions', line 63, column 41 to line 87, column 1)",
  " (in 'User-defined functions', line 100, column 10 to column 29)",
  " (in 'User-defined functions', line 100, column 2 to column 33)",
  " (in 'User-defined functions', line 103, column 4 to column 29)",
  " (in 'User-defined functions', line 102, column 2 to line 103, column 29)",
  " (in 'User-defined functions', line 105, column 2 to column 27)",
  " (in 'User-defined functions', line 106, column 2 to column 11)",
  " (in 'User-defined functions', line 88, column 43 to line 107, column 1)",
  " (in 'User-defined functions', line 120, column 10 to column 29)",
  " (in 'User-defined functions', line 120, column 2 to column 33)",
  " (in 'User-defined functions', line 123, column 4 to column 29)",
  " (in 'User-defined functions', line 122, column 2 to line 123, column 29)",
  " (in 'User-defined functions', line 125, column 2 to column 13)",
  " (in 'User-defined functions', line 126, column 2 to column 11)",
  " (in 'User-defined functions', line 108, column 43 to line 127, column 1)",
  " (in 'User-defined functions', line 136, column 2 to column 43)",
  " (in 'User-defined functions', line 137, column 2 to column 43)",
  " (in 'User-defined functions', line 138, column 9 to column 14)",
  " (in 'User-defined functions', line 138, column 16 to column 21)",
  " (in 'User-defined functions', line 138, column 2 to column 55)",
  " (in 'User-defined functions', line 141, column 4 to column 45)",
  " (in 'User-defined functions', line 140, column 21 to line 142, column 3)",
  " (in 'User-defined functions', line 140, column 2 to line 142, column 3)",
  " (in 'User-defined functions', line 145, column 4 to column 20)",
  " (in 'User-defined functions', line 144, column 21 to line 146, column 3)",
  " (in 'User-defined functions', line 144, column 2 to line 146, column 3)",
  " (in 'User-defined functions', line 147, column 2 to column 12)",
  " (in 'User-defined functions', line 128, column 47 to line 148, column 1)",
  " (in 'User-defined functions', line 154, column 2 to column 47)",
  " (in 'User-defined functions', line 155, column 9 to column 14)",
  " (in 'User-defined functions', line 155, column 2 to column 43)",
  " (in 'User-defined functions', line 156, column 2 to column 13)",
  " (in 'User-defined functions', line 157, column 2 to column 11)",
  " (in 'User-defined functions', line 149, column 46 to line 158, column 1)",
  " (in 'User-defined functions', line 165, column 2 to column 43)",
  " (in 'User-defined functions', line 166, column 2 to column 43)",
  " (in 'User-defined functions', line 167, column 9 to column 14)",
  " (in 'User-defined functions', line 167, column 15 to column 20)",
  " (in 'User-defined functions', line 167, column 2 to column 56)",
  " (in 'User-defined functions', line 168, column 2 to column 29)",
  " (in 'User-defined functions', line 169, column 2 to column 12)",
  " (in 'User-defined functions', line 159, column 63 to line 170, column 1)",
  " (in 'User-defined functions', line 174, column 2 to column 16)",
  " (in 'User-defined functions', line 173, column 44 to line 175, column 1)",
  " (in 'User-defined functions', line 177, column 2 to column 16)",
  " (in 'User-defined functions', line 176, column 36 to line 178, column 1)",
  " (in 'User-defined functions', line 180, column 2 to column 16)",
  " (in 'User-defined functions', line 179, column 36 to line 181, column 1)",
  " (in 'User-defined functions', line 183, column 2 to column 16)",
  " (in 'User-defined functions', line 182, column 40 to line 184, column 1)",
  " (in 'User-defined functions', line 186, column 2 to column 16)",
  " (in 'User-defined functions', line 185, column 36 to line 187, column 1)",
  " (in 'User-defined functions', line 189, column 2 to column 16)",
  " (in 'User-defined functions', line 188, column 36 to line 190, column 1)",
  " (in 'User-defined functions', line 196, column 2 to column 42)",
  " (in 'User-defined functions', line 197, column 9 to column 10)",
  " (in 'User-defined functions', line 197, column 12 to column 13)",
  " (in 'User-defined functions', line 197, column 2 to column 41)",
  " (in 'User-defined functions', line 201, column 6 to column 20)",
  " (in 'User-defined functions', line 200, column 33 to line 202, column 5)",
  " (in 'User-defined functions', line 200, column 4 to line 202, column 5)",
  " (in 'User-defined functions', line 199, column 40 to line 203, column 3)",
  " (in 'User-defined functions', line 199, column 2 to line 203, column 3)",
  " (in 'User-defined functions', line 205, column 2 to column 15)",
  " (in 'User-defined functions', line 208, column 4 to column 20)",
  " (in 'User-defined functions', line 207, column 21 to line 209, column 3)",
  " (in 'User-defined functions', line 207, column 2 to line 209, column 3)",
  " (in 'User-defined functions', line 211, column 2 to column 15)",
  " (in 'User-defined functions', line 212, column 2 to column 11)",
  " (in 'User-defined functions', line 194, column 85 to line 213, column 1)",
  " (in 'User-defined functions', line 216, column 2 to column 42)",
  " (in 'User-defined functions', line 218, column 9 to column 10)",
  " (in 'User-defined functions', line 218, column 2 to column 35)",
  " (in 'User-defined functions', line 219, column 2 to column 13)",
  " (in 'User-defined functions', line 220, column 2 to column 11)",
  " (in 'User-defined functions', line 214, column 84 to line 221, column 1)",
  " (in 'User-defined functions', line 228, column 2 to column 42)",
  " (in 'User-defined functions', line 229, column 9 to column 10)",
  " (in 'User-defined functions', line 229, column 11 to column 12)",
  " (in 'User-defined functions', line 229, column 2 to column 40)",
  " (in 'User-defined functions', line 230, column 2 to column 79)",
  " (in 'User-defined functions', line 231, column 2 to column 26)",
  " (in 'User-defined functions', line 232, column 2 to column 11)",
  " (in 'User-defined functions', line 222, column 95 to line 233, column 1)",
  " (in 'User-defined functions', line 236, column 2 to column 58)",
  " (in 'User-defined functions', line 238, column 9 to column 10)",
  " (in 'User-defined functions', line 238, column 2 to column 18)",
  " (in 'User-defined functions', line 239, column 2 to column 69)",
  " (in 'User-defined functions', line 241, column 2 to column 24)",
  " (in 'User-defined functions', line 242, column 2 to column 15)",
  " (in 'User-defined functions', line 234, column 118 to line 243, column 1)",
  " (in 'User-defined functions', line 256, column 4 to column 13)",
  " (in 'User-defined functions', line 255, column 9 to line 257, column 3)",
  " (in 'User-defined functions', line 254, column 4 to column 13)",
  " (in 'User-defined functions', line 253, column 12 to line 255, column 3)",
  " (in 'User-defined functions', line 253, column 2 to line 257, column 3)",
  " (in 'User-defined functions', line 258, column 2 to column 11)",
  " (in 'User-defined functions', line 244, column 25 to line 259, column 1)",
  " (in 'User-defined functions', line 272, column 4 to column 13)",
  " (in 'User-defined functions', line 271, column 9 to line 273, column 3)",
  " (in 'User-defined functions', line 270, column 4 to column 13)",
  " (in 'User-defined functions', line 269, column 12 to line 271, column 3)",
  " (in 'User-defined functions', line 269, column 2 to line 273, column 3)",
  " (in 'User-defined functions', line 274, column 2 to column 11)",
  " (in 'User-defined functions', line 260, column 25 to line 275, column 1)",
  " (in 'User-defined functions', line 302, column 2 to column 134)",
  " (in 'User-defined functions', line 276, column 38 to line 303, column 1)",
  " (in 'User-defined functions', line 335, column 2 to column 26)",
  " (in 'User-defined functions', line 304, column 41 to line 336, column 1)",
  " (in 'User-defined functions', line 352, column 2 to column 36)",
  " (in 'User-defined functions', line 337, column 32 to line 353, column 1)",
  " (in 'User-defined functions', line 368, column 2 to column 38)",
  " (in 'User-defined functions', line 354, column 36 to line 369, column 1)",
  " (in 'User-defined functions', line 398, column 11 to column 32)",
  " (in 'User-defined functions', line 398, column 34 to column 43)",
  " (in 'User-defined functions', line 398, column 4 to column 99)",
  " (in 'User-defined functions', line 400, column 10 to column 19)",
  " (in 'User-defined functions', line 400, column 28 to column 49)",
  " (in 'User-defined functions', line 400, column 51 to column 69)",
  " (in 'User-defined functions', line 400, column 4 to column 74)",
  " (in 'User-defined functions', line 401, column 4 to column 101)",
  " (in 'User-defined functions', line 402, column 10 to column 19)",
  " (in 'User-defined functions', line 402, column 28 to column 49)",
  " (in 'User-defined functions', line 402, column 51 to column 69)",
  " (in 'User-defined functions', line 402, column 4 to column 74)",
  " (in 'User-defined functions', line 403, column 4 to column 101)",
  " (in 'User-defined functions', line 405, column 11 to column 35)",
  " (in 'User-defined functions', line 405, column 4 to column 65)",
  " (in 'User-defined functions', line 406, column 11 to column 37)",
  " (in 'User-defined functions', line 406, column 4 to column 73)",
  " (in 'User-defined functions', line 411, column 6 to column 73)",
  " (in 'User-defined functions', line 412, column 6 to column 61)",
  " (in 'User-defined functions', line 413, column 6 to column 61)",
  " (in 'User-defined functions', line 410, column 32 to line 414, column 5)",
  " (in 'User-defined functions', line 410, column 4 to line 414, column 5)",
  " (in 'User-defined functions', line 417, column 4 to line 418, column 55)",
  " (in 'User-defined functions', line 419, column 4 to column 13)",
  " (in 'User-defined functions', line 396, column 4 to line 420, column 1)"};
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,-1>
create_block_diagonal(const T0__& A_arg__, const T1__& B_arg__, std::ostream*
                      pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
rep_diagonal_mat(const T0__& A_arg__, const int& k, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec(const T0__& A_arg__, const int& k, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec_piecewise(const T0__& A_arg__, const int& k, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_stan_scalar<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>, T1__>,-1,1>
append_val_2_vec(const T0__& A_arg__, const T1__& val, std::ostream*
                 pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>>,-1,1>
append_vec_2_val(const T0__& val, const T1__& A_arg__, std::ostream*
                 pstream__);
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_A(const int& degree, std::ostream* pstream__);
Eigen::Matrix<double,-1,1>
create_trend_vector_block_L(const int& degree, std::ostream* pstream__);
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_R(const int& degree, const int& is_constant,
                            std::ostream* pstream__);
int get_num_elements_alpha_trend(const int& degree, std::ostream* pstream__);
int get_num_cols_A_trend(const int& degree, std::ostream* pstream__);
int get_num_rows_A_trend(const int& degree, std::ostream* pstream__);
int get_num_elements_L_trend(const int& degree, std::ostream* pstream__);
int get_num_cols_R_trend(const int& degree, std::ostream* pstream__);
int get_num_rows_R_trend(const int& degree, std::ostream* pstream__);
Eigen::Matrix<double,-1,-1>
create_seasonal_discrete_matrix_block_A(const int& num_seasons, const int&
                                        season_duration, std::ostream*
                                        pstream__);
Eigen::Matrix<double,-1,1>
create_seasonal_discrete_vector_block_L(const int& num_seasons, const int&
                                        season_duration, std::ostream*
                                        pstream__);
template <typename T2__,
          stan::require_all_t<stan::is_stan_scalar<T2__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T2__>,-1,-1>
create_seasonal_discrete_matrix_block_R(const int& num_seasons, const int&
                                        season_duration, const T2__& time,
                                        std::ostream* pstream__);
template <typename T0__, typename T2__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_stan_scalar<T2__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>, T2__>,-1,1>
create_initial_seasonal_discrete_vector_block_alpha(const T0__&
                                                    season_params_arg__,
                                                    const int&
                                                    season_duration,
                                                    const T2__& error_term,
                                                    std::ostream* pstream__);
int max_int(const int& a, const int& b, std::ostream* pstream__);
int min_int(const int& a, const int& b, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,1>
AR(const T0__& y_arg__, const T1__& phi_arg__, const int& t, std::ostream*
   pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,1>
MA(const T0__& xi_arg__, const T1__& theta_arg__, const int& t, std::ostream*
   pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_phi_AR(const T0__& phi_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_theta_MA(const T0__& theta_arg__, std::ostream* pstream__);
template <typename T3__, typename T4__, typename T5__, typename T6__,
          typename T7__, typename T8__, typename T9__, typename T10__,
          typename T11__, typename T12__, typename T13__, typename T14__,
          typename T15__, typename T16__, typename T17__, typename T18__,
          typename T19__, typename T20__, typename T21__, typename T22__,
          typename T23__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>,
                              stan::is_eigen_matrix_dynamic<T4__>,
                              stan::is_vt_not_complex<T4__>,
                              stan::is_eigen_matrix_dynamic<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_eigen_matrix_dynamic<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_col_vector<T7__>,
                              stan::is_vt_not_complex<T7__>,
                              stan::is_col_vector<T8__>,
                              stan::is_vt_not_complex<T8__>,
                              stan::is_stan_scalar<T9__>,
                              stan::is_stan_scalar<T10__>,
                              stan::is_stan_scalar<T11__>,
                              stan::is_stan_scalar<T12__>,
                              stan::is_eigen_matrix_dynamic<T13__>,
                              stan::is_vt_not_complex<T13__>,
                              stan::is_eigen_matrix_dynamic<T14__>,
                              stan::is_vt_not_complex<T14__>,
                              stan::is_stan_scalar<T15__>,
                              stan::is_stan_scalar<T16__>,
                              stan::is_stan_scalar<T17__>,
                              stan::is_stan_scalar<T18__>,
                              stan::is_col_vector<T19__>,
                              stan::is_vt_not_complex<T19__>,
                              stan::is_eigen_matrix_dynamic<T20__>,
                              stan::is_vt_not_complex<T20__>,
                              stan::is_col_vector<T21__>,
                              stan::is_vt_not_complex<T21__>,
                              stan::is_col_vector<T22__>,
                              stan::is_vt_not_complex<T22__>,
                              stan::is_eigen_matrix_dynamic<T23__>,
                              stan::is_vt_not_complex<T23__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T3__>,
                stan::base_type_t<T4__>, stan::base_type_t<T5__>,
                stan::base_type_t<T6__>, stan::base_type_t<T7__>,
                stan::promote_args_t<stan::base_type_t<T8__>, T9__, T10__,
                  T11__, T12__,
                  stan::promote_args_t<stan::base_type_t<T13__>,
                    stan::base_type_t<T14__>, T15__, T16__, T17__,
                    stan::promote_args_t<T18__, stan::base_type_t<T19__>,
                      stan::base_type_t<T20__>, stan::base_type_t<T21__>,
                      stan::base_type_t<T22__>,
                      stan::promote_args_t<stan::base_type_t<T23__>>>>>>,-1,-1>
state_space_process(const int& num_steps, const int& num_delays, const int&
                    num_strata, const T3__& A_mu_arg__, const T4__&
                    A_nu_arg__, const T5__& R_mu_arg__, const T6__&
                    R_nu_arg__, const T7__& L_mu_arg__, const T8__&
                    L_nu_arg__, const std::vector<Eigen::Matrix<T9__,-1,-1>>&
                    xi_mu_centered,
                    const std::vector<Eigen::Matrix<T10__,-1,-1>>&
                    xi_nu_centered, const T11__& xi_mu_sd, const T12__&
                    xi_nu_sd, const T13__& mu_0_centered_arg__, const T14__&
                    nu_0_centered_arg__, const T15__& mu_0_sd, const T16__&
                    nu_0_sd, const T17__& mu_0_mean, const T18__& nu_0_mean,
                    const T19__& B_cnt_arg__, const T20__& X_cnt_arg__,
                    const T21__& phi_AR_arg__, const T22__& theta_MA_arg__,
                    const T23__& xi_arg__, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,-1>
create_block_diagonal(const T0__& A_arg__, const T1__& B_arg__, std::ostream*
                      pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  const auto& B = stan::math::to_ref(B_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 1;
    stan::math::validate_non_negative_index("C", "rows(A) + rows(B)",
      (stan::math::rows(A) + stan::math::rows(B)));
    current_statement__ = 2;
    stan::math::validate_non_negative_index("C", "cols(A) + cols(B)",
      (stan::math::cols(A) + stan::math::cols(B)));
    Eigen::Matrix<local_scalar_t__,-1,-1> C =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant((stan::math::rows(A) +
        stan::math::rows(B)), (stan::math::cols(A) + stan::math::cols(B)),
        DUMMY_VAR__);
    current_statement__ = 3;
    stan::model::assign(C,
      stan::math::rep_matrix(0, (stan::math::rows(A) + stan::math::rows(B)),
        (stan::math::cols(A) + stan::math::cols(B))), "assigning variable C");
    current_statement__ = 4;
    stan::model::assign(C, A, "assigning variable C",
      stan::model::index_min_max(1, stan::math::rows(A)),
      stan::model::index_min_max(1, stan::math::cols(A)));
    current_statement__ = 5;
    stan::model::assign(C, B, "assigning variable C",
      stan::model::index_min_max((stan::math::rows(A) + 1),
        (stan::math::rows(A) + stan::math::rows(B))),
      stan::model::index_min_max((stan::math::cols(A) + 1),
        (stan::math::cols(A) + stan::math::cols(B))));
    current_statement__ = 6;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
rep_diagonal_mat(const T0__& A_arg__, const int& k, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 8;
    stan::math::validate_non_negative_index("C", "rows(A) * k",
      (stan::math::rows(A) * k));
    current_statement__ = 9;
    stan::math::validate_non_negative_index("C", "cols(A) * k",
      (stan::math::cols(A) * k));
    Eigen::Matrix<local_scalar_t__,-1,-1> C =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant((stan::math::rows(A) *
        k), (stan::math::cols(A) * k), DUMMY_VAR__);
    current_statement__ = 10;
    stan::model::assign(C,
      stan::math::rep_matrix(0, (stan::math::rows(A) * k),
        (stan::math::cols(A) * k)), "assigning variable C");
    current_statement__ = 13;
    for (int l = 1; l <= k; ++l) {
      current_statement__ = 11;
      stan::model::assign(C, A, "assigning variable C",
        stan::model::index_min_max((((l - 1) * stan::math::rows(A)) + 1), (l
          * stan::math::rows(A))),
        stan::model::index_min_max((((l - 1) * stan::math::cols(A)) + 1), (l
          * stan::math::cols(A))));
    }
    current_statement__ = 14;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec(const T0__& A_arg__, const int& k, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 16;
    stan::math::validate_non_negative_index("C", "num_elements(A) * k",
      (stan::math::num_elements(A) * k));
    Eigen::Matrix<local_scalar_t__,-1,1> C =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((stan::math::num_elements(
                                                        A) * k), DUMMY_VAR__);
    current_statement__ = 20;
    for (int l = 1; l <= k; ++l) {
      current_statement__ = 18;
      stan::model::assign(C, A, "assigning variable C",
        stan::model::index_min_max((((l - 1) * stan::math::num_elements(A)) +
          1), (l * stan::math::num_elements(A))));
    }
    current_statement__ = 21;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec_piecewise(const T0__& A_arg__, const int& k, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int n = std::numeric_limits<int>::min();
    current_statement__ = 23;
    n = stan::math::num_elements(A);
    current_statement__ = 24;
    stan::math::validate_non_negative_index("C", "n * k", (n * k));
    Eigen::Matrix<local_scalar_t__,-1,1> C =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((n * k), DUMMY_VAR__);
    current_statement__ = 28;
    for (int j = 1; j <= n; ++j) {
      current_statement__ = 26;
      stan::model::assign(C,
        stan::math::rep_vector(
          stan::model::rvalue(A, "A", stan::model::index_uni(j)), k),
        "assigning variable C",
        stan::model::index_min_max((((j - 1) * k) + 1), (k * j)));
    }
    current_statement__ = 29;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_stan_scalar<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>, T1__>,-1,1>
append_val_2_vec(const T0__& A_arg__, const T1__& val, std::ostream*
                 pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             T1__>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 31;
    stan::math::validate_non_negative_index("B", "num_elements(A) + 1",
      (stan::math::num_elements(A) + 1));
    Eigen::Matrix<local_scalar_t__,-1,1> B =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((stan::math::num_elements(
                                                        A) + 1), DUMMY_VAR__);
    current_statement__ = 34;
    if (stan::math::logical_gt(stan::math::num_elements(A), 0)) {
      current_statement__ = 33;
      stan::model::assign(B, A, "assigning variable B",
        stan::model::index_min_max(1, stan::math::num_elements(A)));
    }
    current_statement__ = 35;
    stan::model::assign(B, val, "assigning variable B",
      stan::model::index_uni(stan::math::num_elements(B)));
    current_statement__ = 36;
    return B;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>>,-1,1>
append_vec_2_val(const T0__& val, const T1__& A_arg__, std::ostream*
                 pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 38;
    stan::math::validate_non_negative_index("B", "num_elements(A) + 1",
      (stan::math::num_elements(A) + 1));
    Eigen::Matrix<local_scalar_t__,-1,1> B =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((stan::math::num_elements(
                                                        A) + 1), DUMMY_VAR__);
    current_statement__ = 41;
    if (stan::math::logical_gt(stan::math::num_elements(A), 0)) {
      current_statement__ = 40;
      stan::model::assign(B, A, "assigning variable B",
        stan::model::index_min_max(2, stan::math::num_elements(B)));
    }
    current_statement__ = 42;
    stan::model::assign(B, val, "assigning variable B",
      stan::model::index_uni(1));
    current_statement__ = 43;
    return B;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_A(const int& degree, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int ncols = std::numeric_limits<int>::min();
    current_statement__ = 45;
    ncols = get_num_cols_A_trend(degree, pstream__);
    int nrows = std::numeric_limits<int>::min();
    current_statement__ = 46;
    nrows = get_num_rows_A_trend(degree, pstream__);
    current_statement__ = 47;
    stan::math::validate_non_negative_index("A", "nrows", nrows);
    current_statement__ = 48;
    stan::math::validate_non_negative_index("A", "ncols", ncols);
    Eigen::Matrix<local_scalar_t__,-1,-1> A =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nrows, ncols,
        DUMMY_VAR__);
    current_statement__ = 49;
    stan::model::assign(A, stan::math::rep_matrix(0, nrows, ncols),
      "assigning variable A");
    current_statement__ = 52;
    for (int j = 1; j <= ncols; ++j) {
      current_statement__ = 50;
      stan::model::assign(A, (stan::math::pow(-1, (j + 1)) *
        stan::math::choose(degree, j)), "assigning variable A",
        stan::model::index_uni(1), stan::model::index_uni(j));
    }
    current_statement__ = 55;
    for (int i = 2; i <= nrows; ++i) {
      current_statement__ = 53;
      stan::model::assign(A, 1.0, "assigning variable A",
        stan::model::index_uni(i), stan::model::index_uni((i - 1)));
    }
    current_statement__ = 56;
    return stan::math::transpose(A);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
Eigen::Matrix<double,-1,1>
create_trend_vector_block_L(const int& degree, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int nsize = std::numeric_limits<int>::min();
    current_statement__ = 58;
    nsize = get_num_elements_L_trend(degree, pstream__);
    current_statement__ = 59;
    stan::math::validate_non_negative_index("L", "nsize", nsize);
    Eigen::Matrix<local_scalar_t__,-1,1> L =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nsize, DUMMY_VAR__);
    current_statement__ = 60;
    stan::model::assign(L, stan::math::rep_vector(0.0, nsize),
      "assigning variable L");
    current_statement__ = 61;
    stan::model::assign(L, 1.0, "assigning variable L",
      stan::model::index_uni(1));
    current_statement__ = 62;
    return L;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_R(const int& degree, const int& is_constant,
                            std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int ncols = std::numeric_limits<int>::min();
    current_statement__ = 64;
    ncols = get_num_cols_R_trend(degree, pstream__);
    int nrows = std::numeric_limits<int>::min();
    current_statement__ = 65;
    nrows = get_num_rows_R_trend(degree, pstream__);
    current_statement__ = 66;
    stan::math::validate_non_negative_index("R", "nrows", nrows);
    current_statement__ = 67;
    stan::math::validate_non_negative_index("R", "ncols", ncols);
    Eigen::Matrix<local_scalar_t__,-1,-1> R =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nrows, ncols,
        DUMMY_VAR__);
    current_statement__ = 68;
    stan::model::assign(R, stan::math::rep_matrix(0.0, nrows, ncols),
      "assigning variable R");
    current_statement__ = 69;
    stan::model::assign(R, (1.0 - is_constant), "assigning variable R",
      stan::model::index_uni(1), stan::model::index_uni(1));
    current_statement__ = 70;
    return stan::math::transpose(R);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int get_num_elements_alpha_trend(const int& degree, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 72;
    return degree;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int get_num_cols_A_trend(const int& degree, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 74;
    return degree;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int get_num_rows_A_trend(const int& degree, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 76;
    return degree;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int get_num_elements_L_trend(const int& degree, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 78;
    return degree;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int get_num_cols_R_trend(const int& degree, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 80;
    return degree;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int get_num_rows_R_trend(const int& degree, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 82;
    return degree;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
Eigen::Matrix<double,-1,-1>
create_seasonal_discrete_matrix_block_A(const int& num_seasons, const int&
                                        season_duration, std::ostream*
                                        pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int k = std::numeric_limits<int>::min();
    current_statement__ = 84;
    k = ((num_seasons * season_duration) + 1);
    current_statement__ = 85;
    stan::math::validate_non_negative_index("A", "k", k);
    current_statement__ = 86;
    stan::math::validate_non_negative_index("A", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,-1> A =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(k, k, DUMMY_VAR__);
    current_statement__ = 87;
    stan::model::assign(A, stan::math::rep_matrix(0.0, k, k),
      "assigning variable A");
    current_statement__ = 92;
    for (int j = 1; j <= ((k - season_duration) - 1); ++j) {
      current_statement__ = 90;
      if (stan::math::logical_eq(stan::math::modulus(j, season_duration), 0)) {
        current_statement__ = 88;
        stan::model::assign(A, -1.0, "assigning variable A",
          stan::model::index_uni(1), stan::model::index_uni(j));
      }
    }
    current_statement__ = 93;
    stan::model::assign(A, 1.0, "assigning variable A",
      stan::model::index_uni(1), stan::model::index_uni(k));
    current_statement__ = 96;
    for (int i = 2; i <= (k - 1); ++i) {
      current_statement__ = 94;
      stan::model::assign(A, 1.0, "assigning variable A",
        stan::model::index_uni(i), stan::model::index_uni((i - 1)));
    }
    current_statement__ = 97;
    stan::model::assign(A, 1.0, "assigning variable A",
      stan::model::index_uni(k), stan::model::index_uni(k));
    current_statement__ = 98;
    return A;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
Eigen::Matrix<double,-1,1>
create_seasonal_discrete_vector_block_L(const int& num_seasons, const int&
                                        season_duration, std::ostream*
                                        pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int k = std::numeric_limits<int>::min();
    current_statement__ = 100;
    k = ((num_seasons * season_duration) + 1);
    current_statement__ = 101;
    stan::math::validate_non_negative_index("L", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,1> L =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
    current_statement__ = 102;
    stan::model::assign(L, stan::math::rep_vector(0.0, k),
      "assigning variable L");
    current_statement__ = 103;
    stan::model::assign(L, 1.0, "assigning variable L",
      stan::model::index_uni(1));
    current_statement__ = 104;
    return L;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T2__, stan::require_all_t<stan::is_stan_scalar<T2__>>*>
Eigen::Matrix<stan::promote_args_t<T2__>,-1,-1>
create_seasonal_discrete_matrix_block_R(const int& num_seasons, const int&
                                        season_duration, const T2__& time,
                                        std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T2__>;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int k = std::numeric_limits<int>::min();
    current_statement__ = 106;
    k = ((num_seasons * season_duration) + 1);
    current_statement__ = 107;
    stan::math::validate_non_negative_index("R", "k", k);
    current_statement__ = 108;
    stan::math::validate_non_negative_index("R", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,-1> R =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(k, k, DUMMY_VAR__);
    current_statement__ = 109;
    stan::model::assign(R, stan::math::rep_matrix(0.0, k, k),
      "assigning variable R");
    local_scalar_t__ reminder = DUMMY_VAR__;
    current_statement__ = 110;
    reminder = (stan::math::ceil((time / season_duration)) -
      stan::math::floor((time / season_duration)));
    current_statement__ = 111;
    stan::model::assign(R, (1.0 - reminder), "assigning variable R",
      stan::model::index_uni(k), stan::model::index_uni(k));
    current_statement__ = 112;
    return R;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T2__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_stan_scalar<T2__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>, T2__>,-1,1>
create_initial_seasonal_discrete_vector_block_alpha(const T0__&
                                                    season_params_arg__,
                                                    const int&
                                                    season_duration,
                                                    const T2__& error_term,
                                                    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             T2__>;
  int current_statement__ = 0;
  const auto& season_params = stan::math::to_ref(season_params_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int k = std::numeric_limits<int>::min();
    current_statement__ = 114;
    k = ((stan::math::num_elements(season_params) * season_duration) + 1);
    current_statement__ = 115;
    stan::math::validate_non_negative_index("alpha", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,1> alpha =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
    current_statement__ = 117;
    stan::model::assign(alpha,
      rep_vec_piecewise(season_params, season_duration, pstream__),
      "assigning variable alpha", stan::model::index_min_max(1, (k - 1)));
    current_statement__ = 118;
    stan::model::assign(alpha, error_term, "assigning variable alpha",
      stan::model::index_uni(k));
    current_statement__ = 119;
    return alpha;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int max_int(const int& a, const int& b, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 125;
    if (stan::math::logical_gt(a, b)) {
      current_statement__ = 123;
      return a;
    } else {
      current_statement__ = 121;
      return b;
    }
    current_statement__ = 126;
    return 1;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int min_int(const int& a, const int& b, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 132;
    if (stan::math::logical_gt(a, b)) {
      current_statement__ = 130;
      return b;
    } else {
      current_statement__ = 128;
      return a;
    }
    current_statement__ = 133;
    return 1;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,1>
AR(const T0__& y_arg__, const T1__& phi_arg__, const int& t, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  const auto& y = stan::math::to_ref(y_arg__);
  const auto& phi = stan::math::to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 135;
    return stan::math::multiply(
             stan::model::rvalue(y, "y", stan::model::index_omni(),
               stan::model::index_min_max(((t + 1) -
                 min_int(t, stan::math::num_elements(phi), pstream__)), t)),
             stan::model::rvalue(phi, "phi",
               stan::model::index_min_max(((stan::math::num_elements(phi) +
                 1) - min_int(t, stan::math::num_elements(phi), pstream__)),
                 stan::math::num_elements(phi))));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,1>
MA(const T0__& xi_arg__, const T1__& theta_arg__, const int& t, std::ostream*
   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  const auto& xi = stan::math::to_ref(xi_arg__);
  const auto& theta = stan::math::to_ref(theta_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 137;
    return AR(xi, theta, t, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_phi_AR(const T0__& phi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& phi = stan::math::to_ref(phi_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 139;
    return append_val_2_vec(phi, 0.0, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_theta_MA(const T0__& theta_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& theta = stan::math::to_ref(theta_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 141;
    return append_val_2_vec(theta, 1.0, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T3__, typename T4__, typename T5__, typename T6__,
          typename T7__, typename T8__, typename T9__, typename T10__,
          typename T11__, typename T12__, typename T13__, typename T14__,
          typename T15__, typename T16__, typename T17__, typename T18__,
          typename T19__, typename T20__, typename T21__, typename T22__,
          typename T23__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>,
                              stan::is_eigen_matrix_dynamic<T4__>,
                              stan::is_vt_not_complex<T4__>,
                              stan::is_eigen_matrix_dynamic<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_eigen_matrix_dynamic<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_col_vector<T7__>,
                              stan::is_vt_not_complex<T7__>,
                              stan::is_col_vector<T8__>,
                              stan::is_vt_not_complex<T8__>,
                              stan::is_stan_scalar<T9__>,
                              stan::is_stan_scalar<T10__>,
                              stan::is_stan_scalar<T11__>,
                              stan::is_stan_scalar<T12__>,
                              stan::is_eigen_matrix_dynamic<T13__>,
                              stan::is_vt_not_complex<T13__>,
                              stan::is_eigen_matrix_dynamic<T14__>,
                              stan::is_vt_not_complex<T14__>,
                              stan::is_stan_scalar<T15__>,
                              stan::is_stan_scalar<T16__>,
                              stan::is_stan_scalar<T17__>,
                              stan::is_stan_scalar<T18__>,
                              stan::is_col_vector<T19__>,
                              stan::is_vt_not_complex<T19__>,
                              stan::is_eigen_matrix_dynamic<T20__>,
                              stan::is_vt_not_complex<T20__>,
                              stan::is_col_vector<T21__>,
                              stan::is_vt_not_complex<T21__>,
                              stan::is_col_vector<T22__>,
                              stan::is_vt_not_complex<T22__>,
                              stan::is_eigen_matrix_dynamic<T23__>,
                              stan::is_vt_not_complex<T23__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T3__>,
                stan::base_type_t<T4__>, stan::base_type_t<T5__>,
                stan::base_type_t<T6__>, stan::base_type_t<T7__>,
                stan::promote_args_t<stan::base_type_t<T8__>, T9__, T10__,
                  T11__, T12__,
                  stan::promote_args_t<stan::base_type_t<T13__>,
                    stan::base_type_t<T14__>, T15__, T16__, T17__,
                    stan::promote_args_t<T18__, stan::base_type_t<T19__>,
                      stan::base_type_t<T20__>, stan::base_type_t<T21__>,
                      stan::base_type_t<T22__>,
                      stan::promote_args_t<stan::base_type_t<T23__>>>>>>,-1,-1>
state_space_process(const int& num_steps, const int& num_delays, const int&
                    num_strata, const T3__& A_mu_arg__, const T4__&
                    A_nu_arg__, const T5__& R_mu_arg__, const T6__&
                    R_nu_arg__, const T7__& L_mu_arg__, const T8__&
                    L_nu_arg__, const std::vector<Eigen::Matrix<T9__,-1,-1>>&
                    xi_mu_centered,
                    const std::vector<Eigen::Matrix<T10__,-1,-1>>&
                    xi_nu_centered, const T11__& xi_mu_sd, const T12__&
                    xi_nu_sd, const T13__& mu_0_centered_arg__, const T14__&
                    nu_0_centered_arg__, const T15__& mu_0_sd, const T16__&
                    nu_0_sd, const T17__& mu_0_mean, const T18__& nu_0_mean,
                    const T19__& B_cnt_arg__, const T20__& X_cnt_arg__,
                    const T21__& phi_AR_arg__, const T22__& theta_MA_arg__,
                    const T23__& xi_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T3__>,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               T9__, T10__, T11__, T12__,
                               stan::promote_args_t<stan::base_type_t<T13__>,
                                 stan::base_type_t<T14__>, T15__, T16__,
                                 T17__,
                                 stan::promote_args_t<T18__,
                                   stan::base_type_t<T19__>,
                                   stan::base_type_t<T20__>,
                                   stan::base_type_t<T21__>,
                                   stan::base_type_t<T22__>,
                                   stan::promote_args_t<stan::base_type_t<T23__>>>>>>;
  int current_statement__ = 0;
  const auto& A_mu = stan::math::to_ref(A_mu_arg__);
  const auto& A_nu = stan::math::to_ref(A_nu_arg__);
  const auto& R_mu = stan::math::to_ref(R_mu_arg__);
  const auto& R_nu = stan::math::to_ref(R_nu_arg__);
  const auto& L_mu = stan::math::to_ref(L_mu_arg__);
  const auto& L_nu = stan::math::to_ref(L_nu_arg__);
  const auto& mu_0_centered = stan::math::to_ref(mu_0_centered_arg__);
  const auto& nu_0_centered = stan::math::to_ref(nu_0_centered_arg__);
  const auto& B_cnt = stan::math::to_ref(B_cnt_arg__);
  const auto& X_cnt = stan::math::to_ref(X_cnt_arg__);
  const auto& phi_AR = stan::math::to_ref(phi_AR_arg__);
  const auto& theta_MA = stan::math::to_ref(theta_MA_arg__);
  const auto& xi = stan::math::to_ref(xi_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 143;
    stan::math::validate_non_negative_index("l", "num_delays * num_strata",
      (num_delays * num_strata));
    current_statement__ = 144;
    stan::math::validate_non_negative_index("l", "num_steps", num_steps);
    Eigen::Matrix<local_scalar_t__,-1,-1> l =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant((num_delays *
        num_strata), num_steps, DUMMY_VAR__);
    current_statement__ = 145;
    stan::model::assign(l,
      stan::math::rep_matrix(0.0, (num_delays * num_strata), num_steps),
      "assigning variable l");
    current_statement__ = 146;
    stan::math::validate_non_negative_index("mu", "num_steps", num_steps);
    current_statement__ = 147;
    stan::math::validate_non_negative_index("mu", "num_delays * num_strata",
      (num_delays * num_strata));
    current_statement__ = 148;
    stan::math::validate_non_negative_index("mu", "num_elements(L_mu)",
      stan::math::num_elements(L_mu));
    std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> mu =
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(num_steps,
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant((num_delays *
          num_strata), stan::math::num_elements(L_mu), DUMMY_VAR__));
    current_statement__ = 150;
    stan::model::assign(mu,
      stan::math::add(
        stan::math::rep_matrix(mu_0_mean, (num_strata * num_delays),
          stan::math::num_elements(L_mu)),
        stan::math::multiply(mu_0_sd, mu_0_centered)),
      "assigning variable mu", stan::model::index_uni(1));
    current_statement__ = 151;
    stan::math::validate_non_negative_index("nu", "num_steps", num_steps);
    current_statement__ = 152;
    stan::math::validate_non_negative_index("nu", "num_delays * num_strata",
      (num_delays * num_strata));
    current_statement__ = 153;
    stan::math::validate_non_negative_index("nu", "num_elements(L_nu)",
      stan::math::num_elements(L_nu));
    std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> nu =
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(num_steps,
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant((num_delays *
          num_strata), stan::math::num_elements(L_nu), DUMMY_VAR__));
    current_statement__ = 155;
    stan::model::assign(nu,
      stan::math::add(
        stan::math::rep_matrix(nu_0_mean, (num_strata * num_delays),
          stan::math::num_elements(L_nu)),
        stan::math::multiply(nu_0_sd, nu_0_centered)),
      "assigning variable nu", stan::model::index_uni(1));
    current_statement__ = 156;
    stan::math::validate_non_negative_index("phi",
      "num_elements(phi_AR) + 1", (stan::math::num_elements(phi_AR) + 1));
    Eigen::Matrix<local_scalar_t__,-1,1> phi =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((stan::math::num_elements(
                                                        phi_AR) + 1),
        DUMMY_VAR__);
    current_statement__ = 157;
    stan::model::assign(phi, create_phi_AR(phi_AR, pstream__),
      "assigning variable phi");
    current_statement__ = 158;
    stan::math::validate_non_negative_index("theta",
      "num_elements(theta_MA) + 1", (stan::math::num_elements(theta_MA) + 1));
    Eigen::Matrix<local_scalar_t__,-1,1> theta =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((stan::math::num_elements(
                                                        theta_MA) + 1),
        DUMMY_VAR__);
    current_statement__ = 159;
    stan::model::assign(theta, create_theta_MA(theta_MA, pstream__),
      "assigning variable theta");
    current_statement__ = 164;
    for (int t = 1; t <= (num_steps - 1); ++t) {
      current_statement__ = 160;
      stan::model::assign(l,
        stan::math::add(
          stan::math::add(
            stan::math::add(
              stan::math::multiply(
                stan::model::rvalue(mu, "mu", stan::model::index_uni(t)),
                L_mu),
              stan::math::multiply(
                stan::model::rvalue(nu, "nu", stan::model::index_uni(t)),
                L_nu)), AR(stan::model::deep_copy(l), phi, t, pstream__)),
          MA(xi, theta, t, pstream__)), "assigning variable l",
        stan::model::index_omni(), stan::model::index_uni(t));
      current_statement__ = 161;
      stan::model::assign(mu,
        stan::math::add(
          stan::math::multiply(
            stan::model::deep_copy(
              stan::model::rvalue(mu, "mu", stan::model::index_uni(t))), A_mu),
          stan::math::multiply(
            stan::math::multiply(xi_mu_sd,
              stan::model::rvalue(xi_mu_centered, "xi_mu_centered",
                stan::model::index_uni(t))), R_mu)), "assigning variable mu",
        stan::model::index_uni((t + 1)));
      current_statement__ = 162;
      stan::model::assign(nu,
        stan::math::add(
          stan::math::multiply(
            stan::model::deep_copy(
              stan::model::rvalue(nu, "nu", stan::model::index_uni(t))), A_nu),
          stan::math::multiply(
            stan::math::multiply(xi_nu_sd,
              stan::model::rvalue(xi_nu_centered, "xi_nu_centered",
                stan::model::index_uni(t))), R_nu)), "assigning variable nu",
        stan::model::index_uni((t + 1)));
    }
    current_statement__ = 165;
    stan::model::assign(l,
      stan::math::add(
        stan::math::add(
          stan::math::add(
            stan::math::multiply(
              stan::model::rvalue(mu, "mu", stan::model::index_uni(num_steps)),
              L_mu),
            stan::math::multiply(
              stan::model::rvalue(nu, "nu", stan::model::index_uni(num_steps)),
              L_nu)),
          AR(stan::model::deep_copy(l), phi, num_steps, pstream__)),
        MA(xi, theta, num_steps, pstream__)), "assigning variable l",
      stan::model::index_omni(), stan::model::index_uni(num_steps));
    current_statement__ = 166;
    return l;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>,                 stan::base_type_t<double>>,-1,-1> 
create_block_diagonal(const Eigen::Matrix<double,-1,-1>& A,
                      const Eigen::Matrix<double,-1,-1>& B, std::ostream*
                      pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::create_block_diagonal(
           A, B, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,-1> 
rep_diagonal_mat(const Eigen::Matrix<double,-1,-1>& A, const int& k,
                 std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::rep_diagonal_mat(
           A, k, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,1> 
rep_vec(const Eigen::Matrix<double,-1,1>& A, const int& k, std::ostream*
        pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::rep_vec(A, k,
           pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,1> 
rep_vec_piecewise(const Eigen::Matrix<double,-1,1>& A, const int& k,
                  std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::rep_vec_piecewise(
           A, k, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>, double>,-1,1> 
append_val_2_vec(const Eigen::Matrix<double,-1,1>& A, const double& val,
                 std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::append_val_2_vec(
           A, val, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<double, stan::base_type_t<double>>,-1,1> 
append_vec_2_val(const double& val, const Eigen::Matrix<double,-1,1>& A,
                 std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::append_vec_2_val(
           val, A, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<double,-1,-1> 
create_trend_matrix_block_A(const int& degree, std::ostream*
                            pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::create_trend_matrix_block_A(
           degree, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<double,-1,1> 
create_trend_vector_block_L(const int& degree, std::ostream*
                            pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::create_trend_vector_block_L(
           degree, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<double,-1,-1> 
create_trend_matrix_block_R(const int& degree, const int& is_constant,
                            std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::create_trend_matrix_block_R(
           degree, is_constant, pstream__);
}
// [[Rcpp::export]]
 int 
get_num_elements_alpha_trend(const int& degree, std::ostream*
                             pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::get_num_elements_alpha_trend(
           degree, pstream__);
}
// [[Rcpp::export]]
 int 
get_num_cols_A_trend(const int& degree, std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::get_num_cols_A_trend(
           degree, pstream__);
}
// [[Rcpp::export]]
 int 
get_num_rows_A_trend(const int& degree, std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::get_num_rows_A_trend(
           degree, pstream__);
}
// [[Rcpp::export]]
 int 
get_num_elements_L_trend(const int& degree, std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::get_num_elements_L_trend(
           degree, pstream__);
}
// [[Rcpp::export]]
 int 
get_num_cols_R_trend(const int& degree, std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::get_num_cols_R_trend(
           degree, pstream__);
}
// [[Rcpp::export]]
 int 
get_num_rows_R_trend(const int& degree, std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::get_num_rows_R_trend(
           degree, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<double,-1,-1> 
create_seasonal_discrete_matrix_block_A(const int& num_seasons, const int&
                                        season_duration, std::ostream*
                                        pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::create_seasonal_discrete_matrix_block_A(
           num_seasons, season_duration, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<double,-1,1> 
create_seasonal_discrete_vector_block_L(const int& num_seasons, const int&
                                        season_duration, std::ostream*
                                        pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::create_seasonal_discrete_vector_block_L(
           num_seasons, season_duration, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<double>,-1,-1> 
create_seasonal_discrete_matrix_block_R(const int& num_seasons, const int&
                                        season_duration, const double& time,
                                        std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::create_seasonal_discrete_matrix_block_R(
           num_seasons, season_duration, time, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>, double>,-1,1> 
create_initial_seasonal_discrete_vector_block_alpha(const Eigen::Matrix<double,-1,1>&
                                                    season_params, const int&
                                                    season_duration,
                                                    const double& error_term,
                                                    std::ostream*
                                                    pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::create_initial_seasonal_discrete_vector_block_alpha(
           season_params, season_duration, error_term, pstream__);
}
// [[Rcpp::export]]
 int  max_int(const int& a, const int& b, std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::max_int(a, b,
           pstream__);
}
// [[Rcpp::export]]
 int  min_int(const int& a, const int& b, std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::min_int(a, b,
           pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>,                 stan::base_type_t<double>>,-1,1> 
AR(const Eigen::Matrix<double,-1,-1>& y, const Eigen::Matrix<double,-1,1>&
   phi, const int& t, std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::AR(y, phi, t,
           pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>,                 stan::base_type_t<double>>,-1,1> 
MA(const Eigen::Matrix<double,-1,-1>& xi, const Eigen::Matrix<double,-1,1>&
   theta, const int& t, std::ostream* pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::MA(xi, theta, t,
           pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,1> 
create_phi_AR(const Eigen::Matrix<double,-1,1>& phi, std::ostream*
              pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::create_phi_AR(
           phi, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,1> 
create_theta_MA(const Eigen::Matrix<double,-1,1>& theta, std::ostream*
                pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::create_theta_MA(
           theta, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>,                 stan::base_type_t<double>, stan::base_type_t<double>,                 stan::base_type_t<double>, stan::base_type_t<double>,                 stan::promote_args_t<stan::base_type_t<double>, double, double,                   double, double,                   stan::promote_args_t<stan::base_type_t<double>,                     stan::base_type_t<double>, double, double, double,                     stan::promote_args_t<double, stan::base_type_t<double>,                       stan::base_type_t<double>, stan::base_type_t<double>,                       stan::base_type_t<double>,                       stan::promote_args_t<stan::base_type_t<double>>>>>>,-1,-1> 
state_space_process(const int& num_steps, const int& num_delays, const int&
                    num_strata, const Eigen::Matrix<double,-1,-1>& A_mu,
                    const Eigen::Matrix<double,-1,-1>& A_nu,
                    const Eigen::Matrix<double,-1,-1>& R_mu,
                    const Eigen::Matrix<double,-1,-1>& R_nu,
                    const Eigen::Matrix<double,-1,1>& L_mu,
                    const Eigen::Matrix<double,-1,1>& L_nu,
                    const std::vector<Eigen::Matrix<double,-1,-1>>&
                    xi_mu_centered,
                    const std::vector<Eigen::Matrix<double,-1,-1>>&
                    xi_nu_centered, const double& xi_mu_sd, const double&
                    xi_nu_sd, const Eigen::Matrix<double,-1,-1>&
                    mu_0_centered, const Eigen::Matrix<double,-1,-1>&
                    nu_0_centered, const double& mu_0_sd, const double&
                    nu_0_sd, const double& mu_0_mean, const double&
                    nu_0_mean, const Eigen::Matrix<double,-1,1>& B_cnt,
                    const Eigen::Matrix<double,-1,-1>& X_cnt,
                    const Eigen::Matrix<double,-1,1>& phi_AR,
                    const Eigen::Matrix<double,-1,1>& theta_MA,
                    const Eigen::Matrix<double,-1,-1>& xi, std::ostream*
                    pstream__ = 0) {
  return model41f6152663de_User_defined_functions_namespace::state_space_process(
           num_steps, num_delays, num_strata, A_mu, A_nu, R_mu, R_nu, L_mu,
           L_nu, xi_mu_centered, xi_nu_centered, xi_mu_sd, xi_nu_sd,
           mu_0_centered, nu_0_centered, mu_0_sd, nu_0_sd, mu_0_mean,
           nu_0_mean, B_cnt, X_cnt, phi_AR, theta_MA, xi, pstream__);
}
