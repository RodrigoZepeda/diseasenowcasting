// Generated by rstantools.  Do not edit by hand.

// [[Rcpp::depends(StanHeaders)]]
// [[Rcpp::depends(rstan)]]
// [[Rcpp::plugins(rstan)]]
// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::depends(BH)]]
#include <stan/math/prim/fun/Eigen.hpp>
#include <stan/math/prim/meta.hpp>
#include <boost/integer/integer_log2.hpp>
#include <RcppEigen.h>
#ifndef USE_STANC3
#define USE_STANC3
#endif
// Code generated by stanc v2.35.0
#include <stan/model/model_header.hpp>
namespace model50925264e1b1_User_defined_functions_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 122> locations_array__ =
  {" (found before start of program)",
  " (in 'User-defined functions', line 31, column 9 to column 26)",
  " (in 'User-defined functions', line 31, column 28 to column 45)",
  " (in 'User-defined functions', line 31, column 2 to column 103)",
  " (in 'User-defined functions', line 33, column 2 to column 29)",
  " (in 'User-defined functions', line 35, column 2 to column 77)",
  " (in 'User-defined functions', line 36, column 2 to column 11)",
  " (in 'User-defined functions', line 27, column 48 to line 37, column 1)",
  " (in 'User-defined functions', line 42, column 9 to column 18)",
  " (in 'User-defined functions', line 42, column 20 to column 29)",
  " (in 'User-defined functions', line 42, column 2 to column 71)",
  " (in 'User-defined functions', line 45, column 4 to column 76)",
  " (in 'User-defined functions', line 44, column 16 to line 46, column 3)",
  " (in 'User-defined functions', line 44, column 2 to line 46, column 3)",
  " (in 'User-defined functions', line 47, column 2 to column 11)",
  " (in 'User-defined functions', line 38, column 40 to line 48, column 1)",
  " (in 'User-defined functions', line 53, column 9 to column 26)",
  " (in 'User-defined functions', line 53, column 2 to column 30)",
  " (in 'User-defined functions', line 56, column 4 to column 59)",
  " (in 'User-defined functions', line 55, column 16 to line 57, column 3)",
  " (in 'User-defined functions', line 55, column 2 to line 57, column 3)",
  " (in 'User-defined functions', line 58, column 2 to column 11)",
  " (in 'User-defined functions', line 49, column 31 to line 59, column 1)",
  " (in 'User-defined functions', line 67, column 2 to column 26)",
  " (in 'User-defined functions', line 68, column 9 to column 12)",
  " (in 'User-defined functions', line 68, column 2 to column 16)",
  " (in 'User-defined functions', line 71, column 4 to column 51)",
  " (in 'User-defined functions', line 70, column 16 to line 72, column 3)",
  " (in 'User-defined functions', line 70, column 2 to line 72, column 3)",
  " (in 'User-defined functions', line 73, column 2 to column 11)",
  " (in 'User-defined functions', line 60, column 41 to line 74, column 1)",
  " (in 'User-defined functions', line 99, column 9 to column 15)",
  " (in 'User-defined functions', line 99, column 17 to column 23)",
  " (in 'User-defined functions', line 99, column 2 to column 59)",
  " (in 'User-defined functions', line 102, column 4 to column 45)",
  " (in 'User-defined functions', line 101, column 22 to line 103, column 3)",
  " (in 'User-defined functions', line 101, column 2 to line 103, column 3)",
  " (in 'User-defined functions', line 106, column 4 to column 20)",
  " (in 'User-defined functions', line 105, column 22 to line 107, column 3)",
  " (in 'User-defined functions', line 105, column 2 to line 107, column 3)",
  " (in 'User-defined functions', line 108, column 2 to column 11)",
  " (in 'User-defined functions', line 91, column 47 to line 109, column 1)",
  " (in 'User-defined functions', line 115, column 9 to column 15)",
  " (in 'User-defined functions', line 115, column 2 to column 45)",
  " (in 'User-defined functions', line 116, column 2 to column 13)",
  " (in 'User-defined functions', line 117, column 2 to column 11)",
  " (in 'User-defined functions', line 110, column 46 to line 118, column 1)",
  " (in 'User-defined functions', line 124, column 9 to column 15)",
  " (in 'User-defined functions', line 124, column 16 to column 22)",
  " (in 'User-defined functions', line 124, column 2 to column 60)",
  " (in 'User-defined functions', line 125, column 2 to column 29)",
  " (in 'User-defined functions', line 126, column 2 to column 11)",
  " (in 'User-defined functions', line 119, column 63 to line 127, column 1)",
  " (in 'User-defined functions', line 129, column 2 to column 22)",
  " (in 'User-defined functions', line 128, column 67 to line 130, column 1)",
  " (in 'User-defined functions', line 173, column 2 to column 42)",
  " (in 'User-defined functions', line 174, column 9 to column 10)",
  " (in 'User-defined functions', line 174, column 12 to column 13)",
  " (in 'User-defined functions', line 174, column 2 to column 41)",
  " (in 'User-defined functions', line 178, column 6 to column 20)",
  " (in 'User-defined functions', line 177, column 33 to line 179, column 5)",
  " (in 'User-defined functions', line 177, column 4 to line 179, column 5)",
  " (in 'User-defined functions', line 176, column 40 to line 180, column 3)",
  " (in 'User-defined functions', line 176, column 2 to line 180, column 3)",
  " (in 'User-defined functions', line 182, column 2 to column 15)",
  " (in 'User-defined functions', line 185, column 4 to column 20)",
  " (in 'User-defined functions', line 184, column 21 to line 186, column 3)",
  " (in 'User-defined functions', line 184, column 2 to line 186, column 3)",
  " (in 'User-defined functions', line 188, column 2 to column 15)",
  " (in 'User-defined functions', line 189, column 2 to column 11)",
  " (in 'User-defined functions', line 171, column 85 to line 190, column 1)",
  " (in 'User-defined functions', line 193, column 2 to column 42)",
  " (in 'User-defined functions', line 195, column 9 to column 10)",
  " (in 'User-defined functions', line 195, column 2 to column 35)",
  " (in 'User-defined functions', line 196, column 2 to column 13)",
  " (in 'User-defined functions', line 197, column 2 to column 11)",
  " (in 'User-defined functions', line 191, column 84 to line 198, column 1)",
  " (in 'User-defined functions', line 205, column 2 to column 42)",
  " (in 'User-defined functions', line 206, column 9 to column 10)",
  " (in 'User-defined functions', line 206, column 11 to column 12)",
  " (in 'User-defined functions', line 206, column 2 to column 40)",
  " (in 'User-defined functions', line 207, column 2 to column 79)",
  " (in 'User-defined functions', line 208, column 2 to column 26)",
  " (in 'User-defined functions', line 209, column 2 to column 11)",
  " (in 'User-defined functions', line 199, column 95 to line 210, column 1)",
  " (in 'User-defined functions', line 213, column 2 to column 58)",
  " (in 'User-defined functions', line 215, column 9 to column 10)",
  " (in 'User-defined functions', line 215, column 2 to column 18)",
  " (in 'User-defined functions', line 216, column 2 to column 69)",
  " (in 'User-defined functions', line 218, column 2 to column 24)",
  " (in 'User-defined functions', line 219, column 2 to column 15)",
  " (in 'User-defined functions', line 211, column 118 to line 220, column 1)",
  " (in 'User-defined functions', line 269, column 10 to column 19)",
  " (in 'User-defined functions', line 269, column 21 to column 31)",
  " (in 'User-defined functions', line 269, column 33 to column 43)",
  " (in 'User-defined functions', line 269, column 4 to column 57)",
  " (in 'User-defined functions', line 270, column 10 to column 19)",
  " (in 'User-defined functions', line 270, column 21 to column 31)",
  " (in 'User-defined functions', line 270, column 33 to column 43)",
  " (in 'User-defined functions', line 270, column 52 to column 75)",
  " (in 'User-defined functions', line 270, column 4 to column 80)",
  " (in 'User-defined functions', line 271, column 4 to column 21)",
  " (in 'User-defined functions', line 272, column 10 to column 19)",
  " (in 'User-defined functions', line 272, column 21 to column 31)",
  " (in 'User-defined functions', line 272, column 33 to column 43)",
  " (in 'User-defined functions', line 272, column 52 to column 75)",
  " (in 'User-defined functions', line 272, column 4 to column 80)",
  " (in 'User-defined functions', line 273, column 4 to column 21)",
  " (in 'User-defined functions', line 275, column 11 to column 22)",
  " (in 'User-defined functions', line 275, column 4 to column 52)",
  " (in 'User-defined functions', line 281, column 10 to column 89)",
  " (in 'User-defined functions', line 282, column 10 to column 61)",
  " (in 'User-defined functions', line 283, column 10 to column 61)",
  " (in 'User-defined functions', line 279, column 36 to line 284, column 9)",
  " (in 'User-defined functions', line 279, column 8 to line 284, column 9)",
  " (in 'User-defined functions', line 287, column 8 to column 116)",
  " (in 'User-defined functions', line 278, column 29 to line 288, column 7)",
  " (in 'User-defined functions', line 278, column 6 to line 288, column 7)",
  " (in 'User-defined functions', line 277, column 27 to line 289, column 5)",
  " (in 'User-defined functions', line 277, column 4 to line 289, column 5)",
  " (in 'User-defined functions', line 290, column 4 to column 13)",
  " (in 'User-defined functions', line 267, column 28 to line 291, column 1)"};
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,-1>
create_block_diagonal(const T0__& A_arg__, const T1__& B_arg__, std::ostream*
                      pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              std::is_integral<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
rep_diagonal_mat(const T0__& A_arg__, const T1__& k, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              std::is_integral<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec(const T0__& A_arg__, const T1__& k, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              std::is_integral<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec_piecewise(const T0__& A_arg__, const T1__& k, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<std::is_integral<T0__>>* = nullptr>
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_A(const T0__& degree, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<std::is_integral<T0__>>* = nullptr>
Eigen::Matrix<double,-1,1>
create_trend_vector_block_L(const T0__& degree, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>>* = nullptr>
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_R(const T0__& degree, const T1__& is_constant,
                            std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_initial_trend_vector_block_alpha(const T0__& alpha_params_arg__,
                                        std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>>* = nullptr>
Eigen::Matrix<double,-1,-1>
create_seasonal_discrete_matrix_block_A(const T0__& num_seasons, const T1__&
                                        season_duration, std::ostream*
                                        pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>>* = nullptr>
Eigen::Matrix<double,-1,1>
create_seasonal_discrete_vector_block_L(const T0__& num_seasons, const T1__&
                                        season_duration, std::ostream*
                                        pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T2__>,-1,-1>
create_seasonal_discrete_matrix_block_R(const T0__& num_seasons, const T1__&
                                        season_duration, const T2__& time,
                                        std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              std::is_integral<T1__>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>, T2__>,-1,1>
create_initial_seasonal_discrete_vector_block_alpha(const T0__&
                                                    season_params_arg__,
                                                    const T1__&
                                                    season_duration,
                                                    const T2__& error_term,
                                                    std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          typename T12__, typename T13__, typename T14__, typename T15__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>,
                              std::is_integral<T2__>,
                              stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>,
                              stan::is_eigen_matrix_dynamic<T4__>,
                              stan::is_vt_not_complex<T4__>,
                              stan::is_eigen_matrix_dynamic<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_eigen_matrix_dynamic<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_row_vector<T7__>,
                              stan::is_vt_not_complex<T7__>,
                              stan::is_row_vector<T8__>,
                              stan::is_vt_not_complex<T8__>,
                              stan::is_std_vector<T9__>,
                              stan::is_std_vector<stan::value_type_t<T9__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T9__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T9__>>>,
                              stan::is_std_vector<T10__>,
                              stan::is_std_vector<stan::value_type_t<T10__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T10__>>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<
                                                      stan::value_type_t<T10__>>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T10__>>>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>,
                              stan::is_std_vector<T12__>,
                              stan::is_std_vector<stan::value_type_t<T12__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T12__>>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<
                                                      stan::value_type_t<T12__>>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T12__>>>>,
                              stan::is_col_vector<T13__>,
                              stan::is_vt_not_complex<T13__>,
                              stan::is_eigen_matrix_dynamic<T14__>,
                              stan::is_vt_not_complex<T14__>,
                              stan::is_std_vector<T15__>,
                              stan::is_std_vector<stan::value_type_t<T15__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T15__>>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<
                                                      stan::value_type_t<T15__>>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T15__>>>>>* = nullptr>
std::vector<
  std::vector<
    std::vector<
      Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T3__>,
                      stan::base_type_t<T4__>, stan::base_type_t<T5__>,
                      stan::base_type_t<T6__>, stan::base_type_t<T7__>,
                      stan::promote_args_t<stan::base_type_t<T8__>,
                        stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                        stan::base_type_t<T11__>, stan::base_type_t<T12__>,
                        stan::promote_args_t<stan::base_type_t<T13__>,
                          stan::base_type_t<T14__>, stan::base_type_t<T15__>>>>,-1,1>>>>
state_space_process(const T0__& num_steps, const T1__& num_delays,
                    const T2__& num_strata, const T3__& A_mu_arg__,
                    const T4__& A_nu_arg__, const T5__& R_mu_arg__,
                    const T6__& R_nu_arg__, const T7__& L_mu_arg__,
                    const T8__& L_nu_arg__, const T9__& mu_0, const T10__&
                    xi_mu, const T11__& nu_0, const T12__& xi_nu,
                    const T13__& B_cnt_arg__, const T14__& X_cnt_arg__,
                    const T15__& epsilon, std::ostream* pstream__);
// matrix create_block_diagonal(matrix, matrix)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,-1>
create_block_diagonal(const T0__& A_arg__, const T1__& B_arg__, std::ostream*
                      pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& A = stan::math::to_ref(A_arg__);
  const auto& B = stan::math::to_ref(B_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 1;
    stan::math::validate_non_negative_index("C", "rows(A) + rows(B)",
      (stan::math::rows(A) + stan::math::rows(B)));
    current_statement__ = 2;
    stan::math::validate_non_negative_index("C", "cols(A) + cols(B)",
      (stan::math::cols(A) + stan::math::cols(B)));
    Eigen::Matrix<local_scalar_t__,-1,-1> C =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant((stan::math::rows(A) +
        stan::math::rows(B)), (stan::math::cols(A) + stan::math::cols(B)),
        DUMMY_VAR__);
    current_statement__ = 3;
    stan::model::assign(C,
      stan::math::rep_matrix(0, (stan::math::rows(A) + stan::math::rows(B)),
        (stan::math::cols(A) + stan::math::cols(B))), "assigning variable C");
    current_statement__ = 4;
    stan::model::assign(C, A, "assigning variable C",
      stan::model::index_min_max(1, stan::math::rows(A)),
      stan::model::index_min_max(1, stan::math::cols(A)));
    current_statement__ = 5;
    stan::model::assign(C, B, "assigning variable C",
      stan::model::index_min_max((stan::math::rows(A) + 1),
        (stan::math::rows(A) + stan::math::rows(B))),
      stan::model::index_min_max((stan::math::cols(A) + 1),
        (stan::math::cols(A) + stan::math::cols(B))));
    current_statement__ = 6;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// matrix rep_diagonal_mat(matrix, int)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              std::is_integral<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
rep_diagonal_mat(const T0__& A_arg__, const T1__& k, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 8;
    stan::math::validate_non_negative_index("C", "rows(A) * k",
      (stan::math::rows(A) * k));
    current_statement__ = 9;
    stan::math::validate_non_negative_index("C", "cols(A) * k",
      (stan::math::cols(A) * k));
    Eigen::Matrix<local_scalar_t__,-1,-1> C =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant((stan::math::rows(A) *
        k), (stan::math::cols(A) * k), DUMMY_VAR__);
    current_statement__ = 10;
    stan::model::assign(C,
      stan::math::rep_matrix(0, (stan::math::rows(A) * k),
        (stan::math::cols(A) * k)), "assigning variable C");
    current_statement__ = 13;
    for (int l = 1; l <= k; ++l) {
      current_statement__ = 11;
      stan::model::assign(C, A, "assigning variable C",
        stan::model::index_min_max((((l - 1) * stan::math::rows(A)) + 1), (l
          * stan::math::rows(A))),
        stan::model::index_min_max((((l - 1) * stan::math::cols(A)) + 1), (l
          * stan::math::cols(A))));
    }
    current_statement__ = 14;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector rep_vec(vector, int)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              std::is_integral<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec(const T0__& A_arg__, const T1__& k, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 16;
    stan::math::validate_non_negative_index("C", "num_elements(A) * k",
      (stan::math::num_elements(A) * k));
    Eigen::Matrix<local_scalar_t__,-1,1> C =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((stan::math::num_elements(
                                                        A) * k), DUMMY_VAR__);
    current_statement__ = 20;
    for (int l = 1; l <= k; ++l) {
      current_statement__ = 18;
      stan::model::assign(C, A, "assigning variable C",
        stan::model::index_min_max((((l - 1) * stan::math::num_elements(A)) +
          1), (l * stan::math::num_elements(A))));
    }
    current_statement__ = 21;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector rep_vec_piecewise(vector, int)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              std::is_integral<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec_piecewise(const T0__& A_arg__, const T1__& k, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int n = std::numeric_limits<int>::min();
    current_statement__ = 23;
    n = stan::math::num_elements(A);
    current_statement__ = 24;
    stan::math::validate_non_negative_index("C", "n * k", (n * k));
    Eigen::Matrix<local_scalar_t__,-1,1> C =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((n * k), DUMMY_VAR__);
    current_statement__ = 28;
    for (int j = 1; j <= n; ++j) {
      current_statement__ = 26;
      stan::model::assign(C,
        stan::math::rep_vector(
          stan::model::rvalue(A, "A", stan::model::index_uni(j)), k),
        "assigning variable C",
        stan::model::index_min_max((((j - 1) * k) + 1), (k * j)));
    }
    current_statement__ = 29;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// matrix create_trend_matrix_block_A(int)
template <typename T0__, stan::require_all_t<std::is_integral<T0__>>*>
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_A(const T0__& degree, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 31;
    stan::math::validate_non_negative_index("A", "degree", degree);
    current_statement__ = 32;
    stan::math::validate_non_negative_index("A", "degree", degree);
    Eigen::Matrix<local_scalar_t__,-1,-1> A =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(degree, degree,
        DUMMY_VAR__);
    current_statement__ = 33;
    stan::model::assign(A, stan::math::rep_matrix(0, degree, degree),
      "assigning variable A");
    current_statement__ = 36;
    for (int j = 1; j <= degree; ++j) {
      current_statement__ = 34;
      stan::model::assign(A, (stan::math::pow(-(1), (j + 1)) *
        stan::math::choose(degree, j)), "assigning variable A",
        stan::model::index_uni(1), stan::model::index_uni(j));
    }
    current_statement__ = 39;
    for (int i = 2; i <= degree; ++i) {
      current_statement__ = 37;
      stan::model::assign(A, 1.0, "assigning variable A",
        stan::model::index_uni(i), stan::model::index_uni((i - 1)));
    }
    current_statement__ = 40;
    return A;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector create_trend_vector_block_L(int)
template <typename T0__, stan::require_all_t<std::is_integral<T0__>>*>
Eigen::Matrix<double,-1,1>
create_trend_vector_block_L(const T0__& degree, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 42;
    stan::math::validate_non_negative_index("L", "degree", degree);
    Eigen::Matrix<local_scalar_t__,-1,1> L =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(degree, DUMMY_VAR__);
    current_statement__ = 43;
    stan::model::assign(L, stan::math::rep_vector(0.0, degree),
      "assigning variable L");
    current_statement__ = 44;
    stan::model::assign(L, 1.0, "assigning variable L",
      stan::model::index_uni(1));
    current_statement__ = 45;
    return L;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// matrix create_trend_matrix_block_R(int, int)
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>>*>
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_R(const T0__& degree, const T1__& is_constant,
                            std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 47;
    stan::math::validate_non_negative_index("R", "degree", degree);
    current_statement__ = 48;
    stan::math::validate_non_negative_index("R", "degree", degree);
    Eigen::Matrix<local_scalar_t__,-1,-1> R =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(degree, degree,
        DUMMY_VAR__);
    current_statement__ = 49;
    stan::model::assign(R, stan::math::rep_matrix(0.0, degree, degree),
      "assigning variable R");
    current_statement__ = 50;
    stan::model::assign(R, (1.0 - is_constant), "assigning variable R",
      stan::model::index_uni(1), stan::model::index_uni(1));
    current_statement__ = 51;
    return R;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector create_initial_trend_vector_block_alpha(vector)
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_initial_trend_vector_block_alpha(const T0__& alpha_params_arg__,
                                        std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& alpha_params = stan::math::to_ref(alpha_params_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 53;
    return alpha_params;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// matrix create_seasonal_discrete_matrix_block_A(int, int)
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>>*>
Eigen::Matrix<double,-1,-1>
create_seasonal_discrete_matrix_block_A(const T0__& num_seasons, const T1__&
                                        season_duration, std::ostream*
                                        pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int k = std::numeric_limits<int>::min();
    current_statement__ = 55;
    k = ((num_seasons * season_duration) + 1);
    current_statement__ = 56;
    stan::math::validate_non_negative_index("A", "k", k);
    current_statement__ = 57;
    stan::math::validate_non_negative_index("A", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,-1> A =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(k, k, DUMMY_VAR__);
    current_statement__ = 58;
    stan::model::assign(A, stan::math::rep_matrix(0.0, k, k),
      "assigning variable A");
    current_statement__ = 63;
    for (int j = 1; j <= ((k - season_duration) - 1); ++j) {
      current_statement__ = 61;
      if (stan::math::logical_eq(stan::math::modulus(j, season_duration), 0)) {
        current_statement__ = 59;
        stan::model::assign(A, -(1.0), "assigning variable A",
          stan::model::index_uni(1), stan::model::index_uni(j));
      }
    }
    current_statement__ = 64;
    stan::model::assign(A, 1.0, "assigning variable A",
      stan::model::index_uni(1), stan::model::index_uni(k));
    current_statement__ = 67;
    for (int i = 2; i <= (k - 1); ++i) {
      current_statement__ = 65;
      stan::model::assign(A, 1.0, "assigning variable A",
        stan::model::index_uni(i), stan::model::index_uni((i - 1)));
    }
    current_statement__ = 68;
    stan::model::assign(A, 1.0, "assigning variable A",
      stan::model::index_uni(k), stan::model::index_uni(k));
    current_statement__ = 69;
    return A;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector create_seasonal_discrete_vector_block_L(int, int)
template <typename T0__, typename T1__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>>*>
Eigen::Matrix<double,-1,1>
create_seasonal_discrete_vector_block_L(const T0__& num_seasons, const T1__&
                                        season_duration, std::ostream*
                                        pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int k = std::numeric_limits<int>::min();
    current_statement__ = 71;
    k = ((num_seasons * season_duration) + 1);
    current_statement__ = 72;
    stan::math::validate_non_negative_index("L", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,1> L =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
    current_statement__ = 73;
    stan::model::assign(L, stan::math::rep_vector(0.0, k),
      "assigning variable L");
    current_statement__ = 74;
    stan::model::assign(L, 1.0, "assigning variable L",
      stan::model::index_uni(1));
    current_statement__ = 75;
    return L;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// matrix create_seasonal_discrete_matrix_block_R(int, int, real)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>*>
Eigen::Matrix<stan::promote_args_t<T2__>,-1,-1>
create_seasonal_discrete_matrix_block_R(const T0__& num_seasons, const T1__&
                                        season_duration, const T2__& time,
                                        std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T2__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int k = std::numeric_limits<int>::min();
    current_statement__ = 77;
    k = ((num_seasons * season_duration) + 1);
    current_statement__ = 78;
    stan::math::validate_non_negative_index("R", "k", k);
    current_statement__ = 79;
    stan::math::validate_non_negative_index("R", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,-1> R =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(k, k, DUMMY_VAR__);
    current_statement__ = 80;
    stan::model::assign(R, stan::math::rep_matrix(0.0, k, k),
      "assigning variable R");
    local_scalar_t__ reminder = DUMMY_VAR__;
    current_statement__ = 81;
    reminder = (stan::math::ceil((time / season_duration)) -
      stan::math::floor((time / season_duration)));
    current_statement__ = 82;
    stan::model::assign(R, (1.0 - reminder), "assigning variable R",
      stan::model::index_uni(k), stan::model::index_uni(k));
    current_statement__ = 83;
    return R;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// vector create_initial_seasonal_discrete_vector_block_alpha(vector, int, real)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              std::is_integral<T1__>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>, T2__>,-1,1>
create_initial_seasonal_discrete_vector_block_alpha(const T0__&
                                                    season_params_arg__,
                                                    const T1__&
                                                    season_duration,
                                                    const T2__& error_term,
                                                    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             T2__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& season_params = stan::math::to_ref(season_params_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int k = std::numeric_limits<int>::min();
    current_statement__ = 85;
    k = ((stan::math::num_elements(season_params) * season_duration) + 1);
    current_statement__ = 86;
    stan::math::validate_non_negative_index("alpha", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,1> alpha =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
    current_statement__ = 88;
    stan::model::assign(alpha,
      rep_vec_piecewise(season_params, season_duration, pstream__),
      "assigning variable alpha", stan::model::index_min_max(1, (k - 1)));
    current_statement__ = 89;
    stan::model::assign(alpha, error_term, "assigning variable alpha",
      stan::model::index_uni(k));
    current_statement__ = 90;
    return alpha;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
/* array[,,] vector
   state_space_process(int, int, int, matrix, matrix, matrix, matrix,
                       row_vector, row_vector, array[,] vector,
                       array[,,] vector, array[,] vector, array[,,] vector,
                       vector, matrix, array[,,] vector)
 */
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          typename T8__, typename T9__, typename T10__, typename T11__,
          typename T12__, typename T13__, typename T14__, typename T15__,
          stan::require_all_t<std::is_integral<T0__>, std::is_integral<T1__>,
                              std::is_integral<T2__>,
                              stan::is_eigen_matrix_dynamic<T3__>,
                              stan::is_vt_not_complex<T3__>,
                              stan::is_eigen_matrix_dynamic<T4__>,
                              stan::is_vt_not_complex<T4__>,
                              stan::is_eigen_matrix_dynamic<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_eigen_matrix_dynamic<T6__>,
                              stan::is_vt_not_complex<T6__>,
                              stan::is_row_vector<T7__>,
                              stan::is_vt_not_complex<T7__>,
                              stan::is_row_vector<T8__>,
                              stan::is_vt_not_complex<T8__>,
                              stan::is_std_vector<T9__>,
                              stan::is_std_vector<stan::value_type_t<T9__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T9__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T9__>>>,
                              stan::is_std_vector<T10__>,
                              stan::is_std_vector<stan::value_type_t<T10__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T10__>>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<
                                                      stan::value_type_t<T10__>>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T10__>>>>,
                              stan::is_std_vector<T11__>,
                              stan::is_std_vector<stan::value_type_t<T11__>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<T11__>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<T11__>>>,
                              stan::is_std_vector<T12__>,
                              stan::is_std_vector<stan::value_type_t<T12__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T12__>>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<
                                                      stan::value_type_t<T12__>>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T12__>>>>,
                              stan::is_col_vector<T13__>,
                              stan::is_vt_not_complex<T13__>,
                              stan::is_eigen_matrix_dynamic<T14__>,
                              stan::is_vt_not_complex<T14__>,
                              stan::is_std_vector<T15__>,
                              stan::is_std_vector<stan::value_type_t<T15__>>,
                              stan::is_std_vector<stan::value_type_t<
                                                    stan::value_type_t<T15__>>>,
                              stan::is_col_vector<stan::value_type_t<
                                                    stan::value_type_t<
                                                      stan::value_type_t<T15__>>>>,
                              stan::is_vt_not_complex<stan::value_type_t<
                                                        stan::value_type_t<
                                                          stan::value_type_t<T15__>>>>>*>
std::vector<
  std::vector<
    std::vector<
      Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T3__>,
                      stan::base_type_t<T4__>, stan::base_type_t<T5__>,
                      stan::base_type_t<T6__>, stan::base_type_t<T7__>,
                      stan::promote_args_t<stan::base_type_t<T8__>,
                        stan::base_type_t<T9__>, stan::base_type_t<T10__>,
                        stan::base_type_t<T11__>, stan::base_type_t<T12__>,
                        stan::promote_args_t<stan::base_type_t<T13__>,
                          stan::base_type_t<T14__>, stan::base_type_t<T15__>>>>,-1,1>>>>
state_space_process(const T0__& num_steps, const T1__& num_delays,
                    const T2__& num_strata, const T3__& A_mu_arg__,
                    const T4__& A_nu_arg__, const T5__& R_mu_arg__,
                    const T6__& R_nu_arg__, const T7__& L_mu_arg__,
                    const T8__& L_nu_arg__, const T9__& mu_0, const T10__&
                    xi_mu, const T11__& nu_0, const T12__& xi_nu,
                    const T13__& B_cnt_arg__, const T14__& X_cnt_arg__,
                    const T15__& epsilon, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T3__>,
                             stan::base_type_t<T4__>,
                             stan::base_type_t<T5__>,
                             stan::base_type_t<T6__>,
                             stan::base_type_t<T7__>,
                             stan::promote_args_t<stan::base_type_t<T8__>,
                               stan::base_type_t<T9__>,
                               stan::base_type_t<T10__>,
                               stan::base_type_t<T11__>,
                               stan::base_type_t<T12__>,
                               stan::promote_args_t<stan::base_type_t<T13__>,
                                 stan::base_type_t<T14__>,
                                 stan::base_type_t<T15__>>>>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  const auto& A_mu = stan::math::to_ref(A_mu_arg__);
  const auto& A_nu = stan::math::to_ref(A_nu_arg__);
  const auto& R_mu = stan::math::to_ref(R_mu_arg__);
  const auto& R_nu = stan::math::to_ref(R_nu_arg__);
  const auto& L_mu = stan::math::to_ref(L_mu_arg__);
  const auto& L_nu = stan::math::to_ref(L_nu_arg__);
  const auto& B_cnt = stan::math::to_ref(B_cnt_arg__);
  const auto& X_cnt = stan::math::to_ref(X_cnt_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 92;
    stan::math::validate_non_negative_index("l", "num_steps", num_steps);
    current_statement__ = 93;
    stan::math::validate_non_negative_index("l", "num_delays", num_delays);
    current_statement__ = 94;
    stan::math::validate_non_negative_index("l", "num_strata", num_strata);
    std::vector<
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>> l =
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(num_steps,
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(num_delays,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_strata,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(1, DUMMY_VAR__))));
    current_statement__ = 96;
    stan::math::validate_non_negative_index("mu", "num_steps", num_steps);
    current_statement__ = 97;
    stan::math::validate_non_negative_index("mu", "num_delays", num_delays);
    current_statement__ = 98;
    stan::math::validate_non_negative_index("mu", "num_strata", num_strata);
    current_statement__ = 99;
    stan::math::validate_non_negative_index("mu", "num_elements(mu_0[1, 1])",
      stan::math::num_elements(
        stan::model::rvalue(mu_0, "mu_0", stan::model::index_uni(1),
          stan::model::index_uni(1))));
    std::vector<
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>> mu =
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(num_steps,
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(num_delays,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_strata,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(stan::math::num_elements(
                                                             stan::model::rvalue(
                                                               mu_0, "mu_0",
                                                               stan::model::index_uni(
                                                                 1),
                                                               stan::model::index_uni(
                                                                 1))),
              DUMMY_VAR__))));
    current_statement__ = 101;
    stan::model::assign(mu, mu_0, "assigning variable mu",
      stan::model::index_uni(1), stan::model::index_omni(),
      stan::model::index_omni());
    current_statement__ = 102;
    stan::math::validate_non_negative_index("nu", "num_steps", num_steps);
    current_statement__ = 103;
    stan::math::validate_non_negative_index("nu", "num_delays", num_delays);
    current_statement__ = 104;
    stan::math::validate_non_negative_index("nu", "num_strata", num_strata);
    current_statement__ = 105;
    stan::math::validate_non_negative_index("nu", "num_elements(nu_0[1, 1])",
      stan::math::num_elements(
        stan::model::rvalue(nu_0, "nu_0", stan::model::index_uni(1),
          stan::model::index_uni(1))));
    std::vector<
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>> nu =
      std::vector<
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(num_steps,
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(num_delays,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_strata,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(stan::math::num_elements(
                                                             stan::model::rvalue(
                                                               nu_0, "nu_0",
                                                               stan::model::index_uni(
                                                                 1),
                                                               stan::model::index_uni(
                                                                 1))),
              DUMMY_VAR__))));
    current_statement__ = 107;
    stan::model::assign(nu, nu_0, "assigning variable nu",
      stan::model::index_uni(1), stan::model::index_omni(),
      stan::model::index_omni());
    current_statement__ = 108;
    stan::math::validate_non_negative_index("constant_coef", "cols(X_cnt)",
      stan::math::cols(X_cnt));
    Eigen::Matrix<local_scalar_t__,-1,1> constant_coef =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(stan::math::cols(X_cnt),
        DUMMY_VAR__);
    current_statement__ = 109;
    stan::model::assign(constant_coef, stan::math::multiply(X_cnt, B_cnt),
      "assigning variable constant_coef");
    current_statement__ = 119;
    for (int s = 1; s <= num_strata; ++s) {
      current_statement__ = 117;
      for (int d = 1; d <= num_delays; ++d) {
        current_statement__ = 114;
        for (int t = 1; t <= (num_steps - 1); ++t) {
          current_statement__ = 110;
          stan::model::assign(l,
            stan::math::add(
              stan::math::add(
                (stan::math::multiply(L_mu,
                   stan::model::rvalue(mu, "mu", stan::model::index_uni(t),
                     stan::model::index_uni(d), stan::model::index_uni(s))) +
                stan::math::multiply(L_nu,
                  stan::model::rvalue(nu, "nu", stan::model::index_uni(t),
                    stan::model::index_uni(d), stan::model::index_uni(s)))),
                constant_coef),
              stan::model::rvalue(epsilon, "epsilon",
                stan::model::index_uni(t), stan::model::index_uni(d),
                stan::model::index_uni(s))), "assigning variable l",
            stan::model::index_uni(t), stan::model::index_uni(d),
            stan::model::index_uni(s));
          current_statement__ = 111;
          stan::model::assign(mu,
            stan::math::add(
              stan::math::multiply(A_mu,
                stan::model::deep_copy(
                  stan::model::rvalue(mu, "mu", stan::model::index_uni(t),
                    stan::model::index_uni(d), stan::model::index_uni(s)))),
              stan::math::multiply(R_mu,
                stan::model::rvalue(xi_mu, "xi_mu",
                  stan::model::index_uni((t + 1)), stan::model::index_uni(d),
                  stan::model::index_uni(s)))), "assigning variable mu",
            stan::model::index_uni((t + 1)), stan::model::index_uni(d),
            stan::model::index_uni(s));
          current_statement__ = 112;
          stan::model::assign(nu,
            stan::math::add(
              stan::math::multiply(A_nu,
                stan::model::deep_copy(
                  stan::model::rvalue(nu, "nu", stan::model::index_uni(t),
                    stan::model::index_uni(d), stan::model::index_uni(s)))),
              stan::math::multiply(R_nu,
                stan::model::rvalue(xi_nu, "xi_nu",
                  stan::model::index_uni((t + 1)), stan::model::index_uni(d),
                  stan::model::index_uni(s)))), "assigning variable nu",
            stan::model::index_uni((t + 1)), stan::model::index_uni(d),
            stan::model::index_uni(s));
        }
        current_statement__ = 115;
        stan::model::assign(l,
          stan::math::add(
            stan::math::add(
              (stan::math::multiply(L_mu,
                 stan::model::rvalue(mu, "mu",
                   stan::model::index_uni(num_steps),
                   stan::model::index_uni(d), stan::model::index_uni(s))) +
              stan::math::multiply(L_nu,
                stan::model::rvalue(nu, "nu",
                  stan::model::index_uni(num_steps),
                  stan::model::index_uni(d), stan::model::index_uni(s)))),
              constant_coef),
            stan::model::rvalue(epsilon, "epsilon",
              stan::model::index_uni(num_steps), stan::model::index_uni(d),
              stan::model::index_uni(s))), "assigning variable l",
          stan::model::index_uni(num_steps), stan::model::index_uni(d),
          stan::model::index_uni(s));
      }
    }
    current_statement__ = 120;
    return l;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
}
// [[Rcpp::export]]
Eigen::Matrix<double,-1,-1>
create_block_diagonal(const Eigen::Matrix<double,-1,-1>& A,
                      const Eigen::Matrix<double,-1,-1>& B, std::ostream*
                      pstream__ = 0) {
  return model50925264e1b1_User_defined_functions_namespace::create_block_diagonal(
           A, B, pstream__);
}
// [[Rcpp::export]]
Eigen::Matrix<double,-1,-1>
rep_diagonal_mat(const Eigen::Matrix<double,-1,-1>& A, const int& k,
                 std::ostream* pstream__ = 0) {
  return model50925264e1b1_User_defined_functions_namespace::rep_diagonal_mat(
           A, k, pstream__);
}
// [[Rcpp::export]]
Eigen::Matrix<double,-1,1>
rep_vec(const Eigen::Matrix<double,-1,1>& A, const int& k, std::ostream*
        pstream__ = 0) {
  return model50925264e1b1_User_defined_functions_namespace::rep_vec(A, k,
           pstream__);
}
// [[Rcpp::export]]
Eigen::Matrix<double,-1,1>
rep_vec_piecewise(const Eigen::Matrix<double,-1,1>& A, const int& k,
                  std::ostream* pstream__ = 0) {
  return model50925264e1b1_User_defined_functions_namespace::rep_vec_piecewise(
           A, k, pstream__);
}
// [[Rcpp::export]]
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_A(const int& degree, std::ostream*
                            pstream__ = 0) {
  return model50925264e1b1_User_defined_functions_namespace::create_trend_matrix_block_A(
           degree, pstream__);
}
// [[Rcpp::export]]
Eigen::Matrix<double,-1,1>
create_trend_vector_block_L(const int& degree, std::ostream*
                            pstream__ = 0) {
  return model50925264e1b1_User_defined_functions_namespace::create_trend_vector_block_L(
           degree, pstream__);
}
// [[Rcpp::export]]
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_R(const int& degree, const int& is_constant,
                            std::ostream* pstream__ = 0) {
  return model50925264e1b1_User_defined_functions_namespace::create_trend_matrix_block_R(
           degree, is_constant, pstream__);
}
// [[Rcpp::export]]
Eigen::Matrix<double,-1,1>
create_initial_trend_vector_block_alpha(const Eigen::Matrix<double,-1,1>&
                                        alpha_params, std::ostream*
                                        pstream__ = 0) {
  return model50925264e1b1_User_defined_functions_namespace::create_initial_trend_vector_block_alpha(
           alpha_params, pstream__);
}
// [[Rcpp::export]]
Eigen::Matrix<double,-1,-1>
create_seasonal_discrete_matrix_block_A(const int& num_seasons, const int&
                                        season_duration, std::ostream*
                                        pstream__ = 0) {
  return model50925264e1b1_User_defined_functions_namespace::create_seasonal_discrete_matrix_block_A(
           num_seasons, season_duration, pstream__);
}
// [[Rcpp::export]]
Eigen::Matrix<double,-1,1>
create_seasonal_discrete_vector_block_L(const int& num_seasons, const int&
                                        season_duration, std::ostream*
                                        pstream__ = 0) {
  return model50925264e1b1_User_defined_functions_namespace::create_seasonal_discrete_vector_block_L(
           num_seasons, season_duration, pstream__);
}
// [[Rcpp::export]]
Eigen::Matrix<double,-1,-1>
create_seasonal_discrete_matrix_block_R(const int& num_seasons, const int&
                                        season_duration, const double& time,
                                        std::ostream* pstream__ = 0) {
  return model50925264e1b1_User_defined_functions_namespace::create_seasonal_discrete_matrix_block_R(
           num_seasons, season_duration, time, pstream__);
}
// [[Rcpp::export]]
Eigen::Matrix<double,-1,1>
create_initial_seasonal_discrete_vector_block_alpha(const Eigen::Matrix<double,-1,1>&
                                                    season_params, const int&
                                                    season_duration,
                                                    const double& error_term,
                                                    std::ostream*
                                                    pstream__ = 0) {
  return model50925264e1b1_User_defined_functions_namespace::create_initial_seasonal_discrete_vector_block_alpha(
           season_params, season_duration, error_term, pstream__);
}
// [[Rcpp::export]]
std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>
state_space_process(const int& num_steps, const int& num_delays, const int&
                    num_strata, const Eigen::Matrix<double,-1,-1>& A_mu,
                    const Eigen::Matrix<double,-1,-1>& A_nu,
                    const Eigen::Matrix<double,-1,-1>& R_mu,
                    const Eigen::Matrix<double,-1,-1>& R_nu,
                    const Eigen::Matrix<double,1,-1>& L_mu,
                    const Eigen::Matrix<double,1,-1>& L_nu,
                    const std::vector<
                            std::vector<Eigen::Matrix<double,-1,1>>>& mu_0,
                    const std::vector<
                            std::vector<
                              std::vector<Eigen::Matrix<double,-1,1>>>>&
                    xi_mu,
                    const std::vector<
                            std::vector<Eigen::Matrix<double,-1,1>>>& nu_0,
                    const std::vector<
                            std::vector<
                              std::vector<Eigen::Matrix<double,-1,1>>>>&
                    xi_nu, const Eigen::Matrix<double,-1,1>& B_cnt,
                    const Eigen::Matrix<double,-1,-1>& X_cnt,
                    const std::vector<
                            std::vector<
                              std::vector<Eigen::Matrix<double,-1,1>>>>&
                    epsilon, std::ostream* pstream__ = 0) {
  return model50925264e1b1_User_defined_functions_namespace::state_space_process(
           num_steps, num_delays, num_strata, A_mu, A_nu, R_mu, R_nu, L_mu,
           L_nu, mu_0, xi_mu, nu_0, xi_nu, B_cnt, X_cnt, epsilon, pstream__);
}
