// Generated by rstantools.  Do not edit by hand.

// [[Rcpp::depends(StanHeaders)]]
// [[Rcpp::depends(rstan)]]
// [[Rcpp::plugins(rstan)]]
// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::depends(BH)]]
#include <stan/math/prim/fun/Eigen.hpp>
#include <stan/math/prim/meta.hpp>
#include <boost/integer/integer_log2.hpp>
#include <RcppEigen.h>
#ifndef USE_STANC3
#define USE_STANC3
#endif
// Code generated by stanc v2.32.2
#include <stan/model/model_header.hpp>
namespace model42ad91e6e8707_User_defined_functions_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 71> locations_array__ =
  {" (found before start of program)",
  " (in 'User-defined functions', line 7, column 9 to column 26)",
  " (in 'User-defined functions', line 7, column 28 to column 45)",
  " (in 'User-defined functions', line 7, column 2 to column 103)",
  " (in 'User-defined functions', line 9, column 2 to column 29)",
  " (in 'User-defined functions', line 11, column 2 to column 53)",
  " (in 'User-defined functions', line 12, column 2 to column 11)",
  " (in 'User-defined functions', line 3, column 48 to line 13, column 1)",
  " (in 'User-defined functions', line 18, column 9 to column 18)",
  " (in 'User-defined functions', line 18, column 20 to column 29)",
  " (in 'User-defined functions', line 18, column 2 to column 71)",
  " (in 'User-defined functions', line 21, column 4 to column 76)",
  " (in 'User-defined functions', line 20, column 16 to line 22, column 3)",
  " (in 'User-defined functions', line 20, column 2 to line 22, column 3)",
  " (in 'User-defined functions', line 23, column 2 to column 11)",
  " (in 'User-defined functions', line 14, column 40 to line 24, column 1)",
  " (in 'User-defined functions', line 29, column 9 to column 26)",
  " (in 'User-defined functions', line 29, column 2 to column 30)",
  " (in 'User-defined functions', line 32, column 4 to column 59)",
  " (in 'User-defined functions', line 31, column 16 to line 33, column 3)",
  " (in 'User-defined functions', line 31, column 2 to line 33, column 3)",
  " (in 'User-defined functions', line 34, column 2 to column 11)",
  " (in 'User-defined functions', line 25, column 31 to line 35, column 1)",
  " (in 'User-defined functions', line 48, column 9 to column 10)",
  " (in 'User-defined functions', line 48, column 12 to column 13)",
  " (in 'User-defined functions', line 48, column 2 to column 39)",
  " (in 'User-defined functions', line 51, column 4 to column 40)",
  " (in 'User-defined functions', line 50, column 17 to line 52, column 3)",
  " (in 'User-defined functions', line 50, column 2 to line 52, column 3)",
  " (in 'User-defined functions', line 59, column 8 to column 20)",
  " (in 'User-defined functions', line 58, column 13 to line 60, column 7)",
  " (in 'User-defined functions', line 57, column 8 to column 20)",
  " (in 'User-defined functions', line 56, column 22 to line 58, column 7)",
  " (in 'User-defined functions', line 56, column 6 to line 60, column 7)",
  " (in 'User-defined functions', line 55, column 19 to line 61, column 5)",
  " (in 'User-defined functions', line 55, column 4 to line 61, column 5)",
  " (in 'User-defined functions', line 54, column 17 to line 62, column 3)",
  " (in 'User-defined functions', line 54, column 2 to line 62, column 3)",
  " (in 'User-defined functions', line 63, column 2 to column 11)",
  " (in 'User-defined functions', line 40, column 42 to line 64, column 1)",
  " (in 'User-defined functions', line 69, column 9 to column 10)",
  " (in 'User-defined functions', line 69, column 2 to column 35)",
  " (in 'User-defined functions', line 70, column 2 to column 13)",
  " (in 'User-defined functions', line 71, column 2 to column 11)",
  " (in 'User-defined functions', line 65, column 41 to line 72, column 1)",
  " (in 'User-defined functions', line 78, column 9 to column 10)",
  " (in 'User-defined functions', line 78, column 11 to column 12)",
  " (in 'User-defined functions', line 78, column 2 to column 40)",
  " (in 'User-defined functions', line 79, column 2 to column 29)",
  " (in 'User-defined functions', line 80, column 2 to column 11)",
  " (in 'User-defined functions', line 73, column 58 to line 81, column 1)",
  " (in 'User-defined functions', line 83, column 2 to column 15)",
  " (in 'User-defined functions', line 82, column 60 to line 84, column 1)",
  " (in 'User-defined functions', line 88, column 9 to column 10)",
  " (in 'User-defined functions', line 88, column 12 to column 13)",
  " (in 'User-defined functions', line 88, column 2 to column 50)",
  " (in 'User-defined functions', line 89, column 2 to column 32)",
  " (in 'User-defined functions', line 87, column 42 to line 90, column 1)",
  " (in 'User-defined functions', line 92, column 9 to column 10)",
  " (in 'User-defined functions', line 92, column 12 to column 13)",
  " (in 'User-defined functions', line 92, column 2 to column 63)",
  " (in 'User-defined functions', line 93, column 2 to column 32)",
  " (in 'User-defined functions', line 91, column 59 to line 94, column 1)",
  " (in 'User-defined functions', line 96, column 9 to column 10)",
  " (in 'User-defined functions', line 96, column 2 to column 47)",
  " (in 'User-defined functions', line 97, column 2 to column 23)",
  " (in 'User-defined functions', line 95, column 42 to line 98, column 1)",
  " (in 'User-defined functions', line 100, column 2 to column 15)",
  " (in 'User-defined functions', line 99, column 46 to line 101, column 1)",
  " (in 'User-defined functions', line 105, column 2 to column 13)",
  " (in 'User-defined functions', line 104, column 46 to line 106, column 1)"};
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,-1>
create_block_diagonal(const T0__& A_arg__, const T1__& B_arg__, std::ostream*
                      pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
rep_diagonal_mat(const T0__& A_arg__, const int& k, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec(const T0__& A_arg__, const int& k, std::ostream* pstream__);
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_A(const int& k, std::ostream* pstream__);
Eigen::Matrix<double,-1,1>
create_trend_vector_block_L(const int& k, std::ostream* pstream__);
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_R(const int& k, const int& is_constant,
                            std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_initial_trend_vector_block_alpha(const T0__& alpha_arg__,
                                        std::ostream* pstream__);
Eigen::Matrix<double,-1,-1>
create_trend_matrix_A(const int& k, const int& d, std::ostream* pstream__);
Eigen::Matrix<double,-1,-1>
create_trend_matrix_R(const int& k, const int& is_constant, const int& d,
                      std::ostream* pstream__);
Eigen::Matrix<double,-1,1>
create_trend_vector_L(const int& k, const int& d, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_trend_vector_alpha(const T0__& alpha_arg__, std::ostream* pstream__);
int
get_num_elements_alpha_trend(const int& k, const int& d, std::ostream*
                             pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>,
                stan::base_type_t<T1__>>,-1,-1>
create_block_diagonal(const T0__& A_arg__, const T1__& B_arg__, std::ostream*
                      pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T1__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  const auto& B = stan::math::to_ref(B_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 1;
    stan::math::validate_non_negative_index("C", "rows(A) + rows(B)",
      (stan::math::rows(A) + stan::math::rows(B)));
    current_statement__ = 2;
    stan::math::validate_non_negative_index("C", "cols(A) + cols(B)",
      (stan::math::cols(A) + stan::math::cols(B)));
    Eigen::Matrix<local_scalar_t__,-1,-1> C =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant((stan::math::rows(A) +
        stan::math::rows(B)), (stan::math::cols(A) + stan::math::cols(B)),
        DUMMY_VAR__);
    current_statement__ = 3;
    stan::model::assign(C,
      stan::math::rep_matrix(0, (stan::math::rows(A) + stan::math::rows(B)),
        (stan::math::cols(A) + stan::math::cols(B))), "assigning variable C");
    current_statement__ = 4;
    stan::model::assign(C, A, "assigning variable C",
      stan::model::index_min_max(1, stan::math::rows(A)),
      stan::model::index_min_max(1, stan::math::cols(A)));
    current_statement__ = 5;
    stan::model::assign(C, B, "assigning variable C",
      stan::model::index_min_max((stan::math::rows(A) + 1),
        stan::math::rows(C)),
      stan::model::index_min_max((stan::math::cols(A) + 1),
        stan::math::cols(C)));
    current_statement__ = 6;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
rep_diagonal_mat(const T0__& A_arg__, const int& k, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 8;
    stan::math::validate_non_negative_index("C", "rows(A) * k",
      (stan::math::rows(A) * k));
    current_statement__ = 9;
    stan::math::validate_non_negative_index("C", "cols(A) * k",
      (stan::math::cols(A) * k));
    Eigen::Matrix<local_scalar_t__,-1,-1> C =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant((stan::math::rows(A) *
        k), (stan::math::cols(A) * k), DUMMY_VAR__);
    current_statement__ = 10;
    stan::model::assign(C,
      stan::math::rep_matrix(0, (stan::math::rows(A) * k),
        (stan::math::cols(A) * k)), "assigning variable C");
    current_statement__ = 13;
    for (int l = 1; l <= k; ++l) {
      current_statement__ = 11;
      stan::model::assign(C, A, "assigning variable C",
        stan::model::index_min_max((((l - 1) * stan::math::rows(A)) + 1), (l
          * stan::math::rows(A))),
        stan::model::index_min_max((((l - 1) * stan::math::cols(A)) + 1), (l
          * stan::math::cols(A))));
    }
    current_statement__ = 14;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
rep_vec(const T0__& A_arg__, const int& k, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 16;
    stan::math::validate_non_negative_index("C", "num_elements(A) * k",
      (stan::math::num_elements(A) * k));
    Eigen::Matrix<local_scalar_t__,-1,1> C =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant((stan::math::num_elements(
                                                        A) * k), DUMMY_VAR__);
    current_statement__ = 20;
    for (int l = 1; l <= k; ++l) {
      current_statement__ = 18;
      stan::model::assign(C, A, "assigning variable C",
        stan::model::index_min_max((((l - 1) * stan::math::num_elements(A)) +
          1), (l * stan::math::num_elements(A))));
    }
    current_statement__ = 21;
    return C;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_A(const int& k, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 23;
    stan::math::validate_non_negative_index("A", "k", k);
    current_statement__ = 24;
    stan::math::validate_non_negative_index("A", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,-1> A =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(k, k, DUMMY_VAR__);
    current_statement__ = 25;
    stan::model::assign(A, stan::math::rep_matrix(0, k, k),
      "assigning variable A");
    current_statement__ = 28;
    for (int j = 1; j <= k; ++j) {
      current_statement__ = 26;
      stan::model::assign(A, (stan::math::pow(-1, (j + 1)) *
        stan::math::choose(k, j)), "assigning variable A",
        stan::model::index_uni(1), stan::model::index_uni(j));
    }
    current_statement__ = 37;
    for (int i = 2; i <= k; ++i) {
      current_statement__ = 35;
      for (int j = 1; j <= i; ++j) {
        current_statement__ = 33;
        if (stan::math::logical_eq(j, (i - 1))) {
          current_statement__ = 31;
          stan::model::assign(A, 1, "assigning variable A",
            stan::model::index_uni(i), stan::model::index_uni(j));
        } else {
          current_statement__ = 29;
          stan::model::assign(A, 0, "assigning variable A",
            stan::model::index_uni(i), stan::model::index_uni(j));
        }
      }
    }
    current_statement__ = 38;
    return A;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
Eigen::Matrix<double,-1,1>
create_trend_vector_block_L(const int& k, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 40;
    stan::math::validate_non_negative_index("L", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,1> L =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
    current_statement__ = 41;
    stan::model::assign(L, stan::math::rep_vector(0.0, k),
      "assigning variable L");
    current_statement__ = 42;
    stan::model::assign(L, 1.0, "assigning variable L",
      stan::model::index_uni(1));
    current_statement__ = 43;
    return L;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
Eigen::Matrix<double,-1,-1>
create_trend_matrix_block_R(const int& k, const int& is_constant,
                            std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 45;
    stan::math::validate_non_negative_index("R", "k", k);
    current_statement__ = 46;
    stan::math::validate_non_negative_index("R", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,-1> R =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(k, k, DUMMY_VAR__);
    current_statement__ = 47;
    stan::model::assign(R, stan::math::rep_matrix(0.0, k, k),
      "assigning variable R");
    current_statement__ = 48;
    stan::model::assign(R, (1.0 - is_constant), "assigning variable R",
      stan::model::index_uni(1), stan::model::index_uni(1));
    current_statement__ = 49;
    return R;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_initial_trend_vector_block_alpha(const T0__& alpha_arg__,
                                        std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& alpha = stan::math::to_ref(alpha_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 51;
    return alpha;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
Eigen::Matrix<double,-1,-1>
create_trend_matrix_A(const int& k, const int& d, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 53;
    stan::math::validate_non_negative_index("A", "k", k);
    current_statement__ = 54;
    stan::math::validate_non_negative_index("A", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,-1> A =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(k, k, DUMMY_VAR__);
    current_statement__ = 55;
    stan::model::assign(A, create_trend_matrix_block_A(k, pstream__),
      "assigning variable A");
    current_statement__ = 56;
    return rep_diagonal_mat(A, d, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
Eigen::Matrix<double,-1,-1>
create_trend_matrix_R(const int& k, const int& is_constant, const int& d,
                      std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 58;
    stan::math::validate_non_negative_index("R", "k", k);
    current_statement__ = 59;
    stan::math::validate_non_negative_index("R", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,-1> R =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(k, k, DUMMY_VAR__);
    current_statement__ = 60;
    stan::model::assign(R,
      create_trend_matrix_block_R(k, is_constant, pstream__),
      "assigning variable R");
    current_statement__ = 61;
    return rep_diagonal_mat(R, d, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
Eigen::Matrix<double,-1,1>
create_trend_vector_L(const int& k, const int& d, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 63;
    stan::math::validate_non_negative_index("L", "k", k);
    Eigen::Matrix<local_scalar_t__,-1,1> L =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(k, DUMMY_VAR__);
    current_statement__ = 64;
    stan::model::assign(L, create_trend_vector_block_L(k, pstream__),
      "assigning variable L");
    current_statement__ = 65;
    return rep_vec(L, d, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,1>
create_trend_vector_alpha(const T0__& alpha_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& alpha = stan::math::to_ref(alpha_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 67;
    return alpha;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int
get_num_elements_alpha_trend(const int& k, const int& d, std::ostream*
                             pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 69;
    return (k * d);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>,                 stan::base_type_t<double>>,-1,-1> 
create_block_diagonal(const Eigen::Matrix<double,-1,-1>& A,
                      const Eigen::Matrix<double,-1,-1>& B, std::ostream*
                      pstream__ = 0) {
  return model42ad91e6e8707_User_defined_functions_namespace::create_block_diagonal(
           A, B, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,-1> 
rep_diagonal_mat(const Eigen::Matrix<double,-1,-1>& A, const int& k,
                 std::ostream* pstream__ = 0) {
  return model42ad91e6e8707_User_defined_functions_namespace::rep_diagonal_mat(
           A, k, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,1> 
rep_vec(const Eigen::Matrix<double,-1,1>& A, const int& k, std::ostream*
        pstream__ = 0) {
  return model42ad91e6e8707_User_defined_functions_namespace::rep_vec(A, k,
           pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<double,-1,-1> 
create_trend_matrix_block_A(const int& k, std::ostream* pstream__ = 0) {
  return model42ad91e6e8707_User_defined_functions_namespace::create_trend_matrix_block_A(
           k, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<double,-1,1> 
create_trend_vector_block_L(const int& k, std::ostream* pstream__ = 0) {
  return model42ad91e6e8707_User_defined_functions_namespace::create_trend_vector_block_L(
           k, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<double,-1,-1> 
create_trend_matrix_block_R(const int& k, const int& is_constant,
                            std::ostream* pstream__ = 0) {
  return model42ad91e6e8707_User_defined_functions_namespace::create_trend_matrix_block_R(
           k, is_constant, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,1> 
create_initial_trend_vector_block_alpha(const Eigen::Matrix<double,-1,1>&
                                        alpha, std::ostream*
                                        pstream__ = 0) {
  return model42ad91e6e8707_User_defined_functions_namespace::create_initial_trend_vector_block_alpha(
           alpha, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<double,-1,-1> 
create_trend_matrix_A(const int& k, const int& d, std::ostream*
                      pstream__ = 0) {
  return model42ad91e6e8707_User_defined_functions_namespace::create_trend_matrix_A(
           k, d, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<double,-1,-1> 
create_trend_matrix_R(const int& k, const int& is_constant, const int& d,
                      std::ostream* pstream__ = 0) {
  return model42ad91e6e8707_User_defined_functions_namespace::create_trend_matrix_R(
           k, is_constant, d, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<double,-1,1> 
create_trend_vector_L(const int& k, const int& d, std::ostream*
                      pstream__ = 0) {
  return model42ad91e6e8707_User_defined_functions_namespace::create_trend_vector_L(
           k, d, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>>,-1,1> 
create_trend_vector_alpha(const Eigen::Matrix<double,-1,1>& alpha,
                          std::ostream* pstream__ = 0) {
  return model42ad91e6e8707_User_defined_functions_namespace::create_trend_vector_alpha(
           alpha, pstream__);
}
// [[Rcpp::export]]
 int 
get_num_elements_alpha_trend(const int& k, const int& d, std::ostream*
                             pstream__ = 0) {
  return model42ad91e6e8707_User_defined_functions_namespace::get_num_elements_alpha_trend(
           k, d, pstream__);
}
