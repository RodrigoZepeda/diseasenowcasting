#' Makes a summary of your nowcast
#'
#' Makes a tidy summary dataframe of the results of the function [nowcast()]
#'
#' @param object A nowcaster object generated by [nowcast()]
#'
#' @param quantiles A vector specifying the quantiles to include in the summary
#'
#' @param ... Additional options to pass to summary.
#'
#' @return A summary tibble of the nowcast results,
#' it specifies: true date, strata, mean, standard deviation, median, and quantiles
#'
#' @examples
#' # Load the data
#' data(denguedat)
#'
#' # Run a nowcast with very few iterations
#' # change to method = "sampling" when working and remove the iter = 10
#' now <- as.Date("1990-10-01")
#'
#' # perform nowcasting
#' ncast <- nowcast(denguedat, "onset_week", "report_week",
#'   now = now, method = "optimization",
#'   seed = 2495624, iter = 10
#' )
#'
#' # create summary dataframe
#' summary(ncast)
#'
#' # Specific quantiles can be requested
#' summary(ncast, quantiles = c(0.1, 0.2, 0.3, 0.4))
#'
#' @export

summary.nowcaster <- function(object, quantiles = c(0.05, 0.95), ...) {

  if (!is.numeric(quantiles) || any(quantiles < 0 | quantiles > 1)) {
    stop("quantiles must be a number or a numeric vector with values between 0 and 1.")
  }

  # Get names from input data
  true_date_name <- object[["data"]][["call_parameters"]][["true_date"]]

  date_dic <- object[["data"]][["preprocessed_data"]] |>
    dplyr::select(!!as.symbol(".tval"), dplyr::all_of(true_date_name)) |>
    dplyr::distinct()

  predictions_summary <- object[["generated_quantities"]] |>
    posterior::as_draws() |>
    posterior::subset_draws("N_predict") |>
    posterior::summarise_draws("mean","sd","median", ~quantile(.x, probs = quantiles)) |>
    # Extract strata and time values
    dplyr::mutate(
      .strata = as.numeric(stringr::str_remove_all(!!as.symbol("variable"), ".*\\[.*,|\\]")),
      .tval = as.numeric(stringr::str_remove_all(!!as.symbol("variable"), ".*\\[|,.*\\]"))
    ) |>
    # assign the input strata names
    dplyr::left_join(object[["data"]][["strata_dict"]], by = ".strata") |>
    # assign the onset dates
    dplyr::left_join(date_dic, by = ".tval") |>
    # Select and reorder the columns
    dplyr::select(
      !!rlang::sym(true_date_name), dplyr::everything(), -!!as.symbol("variable"),  -!!as.symbol(".tval"), -!!as.symbol(".strata"),
    ) |>
    dplyr::rename(!!as.symbol("Strata_unified") := !!as.symbol(".strata_unified"))

  return(predictions_summary)
}

#' Plot your nowcast
#'
#' Create barplots to show real cases and the predictions of the function diseasenowcasting::nowcast()
#'
#' @param x The output of the [nowcast()] function
#'
#' @param color A string indicating the color for the barplots. Works with the default R colors of
#' [grDevices::colors()]. Hex color codes works as well. Best results with darker colors.
#'
#' @param datesbrakes A string giving the distance between x-axis breaks if not specified, one label
#' per bar. Other valid examples are: "2 weeks", or "10 years", 'sec', 'min', 'hour', 'day', 'week',
#' 'month', 'year', optionally followed by 's'.
#'
#' @param casesbrakes Desired number of y-axis breaks. You may get slightly more or fewer breaks
#' that requested due to dynamic adaptation.
#'
#' @param rowsfacet Number of rows for arranging facets when using [ggplot2::facet_wrap()]. It allows
#' manual control over the layout of multiple strata in the plot.
#'
#' @param colsfacet Number of columns for arranging facets when using [ggplot2::facet_wrap()]. It
#' allows manual control over the layout of multiple strata in the plot.
#'
#' @param quantiles a vector of two values to specify the quantiles for the error bars.
#'
#' @param ... Additional parameters to pass to your plot
#'
#' @return A [ggplot2::ggplot2()] object with barplots to show real cases and the predictions
#' of the function [nowcast()]. It creates a facet for each strata.
#'
#' @examples
#' # Load the data
#' data(denguedat)
#'
#' # Run a nowcast with very few iterations
#' # change to method = "sampling" when working and remove the iter = 10 (or set to iter = 2000)
#' now <- as.Date("1990-10-01")
#'
#' # perform nowcasting
#' ncast <- nowcast(denguedat, "onset_week", "report_week",strata = "gender",
#'                       now = now, method = "optimization",
#'                       seed = 2495624, iter = 10
#'                       )
#'
#'
#' # plot results requires ggplot2 package
#' if (!requireNamespace("ggplot2", quietly = TRUE)){
#'   plot(ncast)
#'
#'   # other plotting options
#'   plot(ncast, rowsfacet = 2,
#'        datesbrakes = "2 weeks", casesbrakes = 15,
#'        color = "deepskyblue3")
#' }
#'
#' @importFrom grDevices col2rgb colors
#' @export
plot.nowcaster <- function(x, color = "#5F7E62", datesbrakes = NULL,
                           casesbrakes = 10, rowsfacet = NULL, colsfacet = NULL,
                           quantiles = c(0.05, 0.95), ...){

  if (!requireNamespace("ggplot2", quietly = TRUE)){
    cli::cli_alert_warning(
      "To produce plots please install the `ggplot2` package."
    )
    return(invisible())
  }

  if (!requireNamespace("scales", quietly = TRUE)){
    cli::cli_alert_warning(
      "To produce plots please install the `scales` package."
    )
    return(invisible())
  }

  # Check if the color is in the built-in colors or is a valid hex code
  if (!(color %in% colors() || grepl("^#([0-9A-Fa-f]{3}){1,2}$", color))) {
    # If it's not valid, try to convert to RGB and catch errors
    if (tryCatch({
      col2rgb(color)
      TRUE  # If successful, return TRUE
    }, error = function(e) {
      FALSE  # If an error occurs, return FALSE
    })) {
      # color is valid as RGB
    } else {
      stop("color is not a valid color string in R.")
    }
  }

  # Check if datesbrakes is either NULL or a valid specification
  if (!is.null(datesbrakes) &&
      !grepl("^\\d+\\s*(day|week|month|year|days|weeks|months|years)$|^(day|week|month|year|days|weeks|months|years)$", datesbrakes)) {
    stop('datesbrakes is not a valid string for date breaks.
         Examples are: "2 weeks", "10 days", "day", "months", "year"...')
  }

  # Check if casesbrakes is a positive integer
  if (!is.null(casesbrakes) && (!is.numeric(casesbrakes) || casesbrakes <= 0 || floor(casesbrakes) != casesbrakes)) {
    stop("casesbrakes must be a positive integer.")
  }

  # Check if rowfacet is NULL or a positive integer
  if (!is.null(rowsfacet) && (!is.numeric(rowsfacet) || rowsfacet <= 0 || floor(rowsfacet) != rowsfacet)) {
    stop("rowsfacet must be NULL or a positive integer.")
  }

  # Check if colsfacet is NULL or a positive integer
  if (!is.null(colsfacet) && (!is.numeric(colsfacet) || colsfacet <= 0 || floor(colsfacet) != colsfacet)) {
    stop("colsfacet must be NULL or a positive integer.")
  }

  # Check if quantiles is valid, and only specify two numbers
  if (!is.numeric(quantiles) || any(quantiles < 0 | quantiles > 1)) {
    stop("quantiles must be a number or a numeric vector with values between 0 and 1.")
  }
  if (length(quantiles)!=2) {
    stop("must specify 2 quantiles for error bars")
  }

  # Get names from input data
  true_date_name <- x$data$call_parameters$true_date
  Strata_unified = "Strata_unified"
  dot_strata_unified = ".strata_unified"

  # Create dictionaries for onset week and strata
  date_dic <- x$data$preprocessed_data |>
    dplyr::select(!!as.symbol(".tval"), !!dplyr::sym(true_date_name)) |>
    dplyr::distinct()
  stata_dic <- x$data$strata_dict

  # Make summary
  prediction_summary <- summary.nowcaster(x, quantiles = quantiles)
  #get quantile labels for legend
  quantile_labels <- paste0(
    colnames(prediction_summary)[5], " - ", colnames(prediction_summary)[6], " interval"
  )
  # Get input data and sum over all delays
  data_delays <- x$data$preprocessed_data |>
    dplyr::group_by(!!as.symbol(".tval"), !!as.symbol(".strata")) |>
    dplyr::summarise(n = sum(!!as.symbol("n")), .groups = "drop") |>
    # Assign the onset dates
    dplyr::left_join(date_dic, by = ".tval") |>
    # Assign the strata names
    dplyr::left_join(stata_dic, by = ".strata") |>
    # Rename the strata column
    dplyr::rename_with(~Strata_unified, .cols = !!rlang::sym(dot_strata_unified))

  plotnow <- ggplot2::ggplot(data_delays) +
    # Add real cases as solid bars (observed)
    ggplot2::geom_bar(
      ggplot2::aes(x = !!dplyr::sym(true_date_name), y = !!as.symbol("n"), fill = "Reported"),
      stat = "identity", position = "dodge", color = NA, alpha = 0.8
    ) +

    # Add predicted median as transparent bars (predicted)
    ggplot2::geom_bar(
      ggplot2::aes(x = !!dplyr::sym(true_date_name), y = !!as.symbol("mean"), fill = "Estimated, not yet reported"),
      stat = "identity", position = "dodge", alpha = 0.45, color = NA, data = prediction_summary
    ) +

    # Add error bars for 95% CI
    ggplot2::geom_errorbar(
      ggplot2::aes(
        x = !!dplyr::sym(true_date_name),
        ymin = !!dplyr::pull(prediction_summary, 5),
        ymax = !!dplyr::pull(prediction_summary, 6),
        group = !!as.symbol("Strata_unified")
      ),
      width = 0,
      color = "gray40",
      data = prediction_summary
    ) +

    # Facet by strata
    ggplot2::facet_wrap(stats::as.formula(paste0("~", Strata_unified)), nrow = rowsfacet, ncol=colsfacet)

  if (!is.null(datesbrakes)) {
    plotnow <- plotnow + ggplot2::scale_x_date(
      date_labels = "%Y-%b-%d",  # Date format
      minor_breaks = NULL,  # Remove minor breaks
      date_breaks = datesbrakes  # datesbrakes specified by user
    )
  } else {
    plotnow <- plotnow + ggplot2::scale_x_date(
      date_labels = "%Y-%b-%d",  # Date format
      minor_breaks = NULL,
      breaks = sort(unique(dplyr::pull(prediction_summary, 1)))  # Ensure each bar has a corresponding date label
    )
  }

  plotnow <- plotnow +
    ggplot2::scale_y_continuous(
      breaks = scales::breaks_pretty(n = casesbrakes),  # Set the number of breaks
      labels = scales::label_number(accuracy = 1),  # Ensure integer labels
      sec.axis = ggplot2::dup_axis()  # Duplicate axis on the right
    ) +

    # Custom legend for fill colors
    ggplot2::scale_fill_manual(
      name = NULL,  # Remove legend title
      values = c("Reported" = color, "Estimated, not yet reported" = color),
      labels = c("Reported", paste("Predicted, not yet reported\nError bars: ", quantile_labels, sep = ""))
    ) +

    # Manually control the legend to show different alpha levels
    ggplot2::guides(
      fill = ggplot2::guide_legend(
        override.aes = list(
          alpha = c(0.8, 0.45),  # Full opacity for "Reported", transparency for "Estimated"
          color = NA  # Make sure the legend matches the bar outlines
        )
      )
    ) +

    # Labels and theme
    ggplot2::labs(
      y = "Cases"
    ) +
    ggplot2::theme_minimal() +
    ggplot2::theme(
      axis.text.x = ggplot2::element_text(angle = 90, vjust = 0.5, hjust = 1),
      legend.position = "top",
      legend.justification='right',
      legend.direction = "horizontal"
    )

  # If all data have the same strata, do not plot the facet title
  if (length(unique(data_delays$.strata)) == 1) {
    plotnow <- plotnow + ggplot2::theme(strip.text = ggplot2::element_blank())
  }

  return(plotnow)
}

#' Print a nowcast object
#'
#' Generic to print a `nowcaster` object
#'
#' @param x A `nowcaster` object generated by [nowcast()]
#'
#' @param ... Additional arguments to pass to print (currently don't do anything)
#'
#' @examples
#' #' # Load the data
#' data(denguedat)
#'
#' # Run a nowcast with very few iterations
#' # change to method = "sampling" when working and remove the iter = 10 (or set to iter = 2000)
#' now   <- as.Date("1990-10-01")
#' ncast <- nowcast(denguedat, "onset_week", "report_week", now = now,
#'   method = "optimization", seed = 2495624, iter = 10)
#' print(ncast)
#'
#' @export
print.nowcaster <- function(x, ...){

  cli::cli_h2("Nowcast for {.val {x[['data']][['call_parameters']][['now']]}}")
  cli::cli_ul()
  cli::cli_li("Column with {.code true_date} = {.val {x[['data']][['call_parameters']][['true_date']]}}")
  cli::cli_li("Column with {.code report_date} = {.val {x[['data']][['call_parameters']][['report_date']]}}")

  if (!is.null(x[['data']][['call_parameters']][['strata']])){
    cli::cli_li(
      "Column with {.code strata} = {.val {x[['data']][['call_parameters']][['strata']]}} contains {.val {x[['data']][['call_parameters']][['num_strata']]}} different values."
    )
  }
  cli::cli_li("units = {.val {x[['data']][['call_parameters']][['units']]}}")
  if (!is.infinite(x[['data']][['call_parameters']][['max_delay']])){
    cli::cli_li("max_delay = {.val {x[['data']][['call_parameters']][['max_delay']]}}")
  }
  cli::cli_end()

  cli::cli_h3("Epidemic effects:")
  print_temporal_effect_internal(x[['data']][['call_parameters']][['temporal_effects_epidemic']])

  cli::cli_h3("Delay effects:")
  print_temporal_effect_internal(x[['data']][['call_parameters']][['temporal_effects_delay']])

  cli::cli_par()
  cli::cli_text(
    "Use the {.code summary} function to obtain the summary of predictions or {.code plot} to generate an image"
  )

}

#' Update a nowcast object
#'
#' Generic to update a `nowcaster` object with new data
#'
#' @param object A `nowcaster` object generated by [nowcast()]
#'
#' @param new_data New `.disease_data` to use for fitting [nowcast()]. Ideally this should include
#' the previous data + new observations in the same `data.frame`.
#'
#' @inheritParams nowcast
#'
#' @examples
#' #' # Load the data
#' data(denguedat)
#'
#' # Run a nowcast using the first 1000 data points
#' first_1k <- denguedat[1:1000,]
#' ncast <- nowcast(first_1k, "onset_week", "report_week",
#'   method = "optimization", seed = 2495624, iter = 10, refresh = 0)
#' ncast
#'
#' #Update the nowcast now that new information was acquired
#' first_3k <- denguedat[1:3000,]
#' update(ncast, new_data = first_3k)
#'
#' @export
update.nowcaster <- function(object, new_data, now = NULL, refresh = 250*rlang::is_interactive(), ...){

  #Get the call parameters
  call_parameters <- object[["data"]][["call_parameters"]] |> append(list(.disease_data = new_data))

  #Update the now and refresh
  call_parameters[["now"]]        <- now
  call_parameters[["refresh"]]    <- refresh

  #Set to null those parameters that are not from call
  call_parameters[["num_delays"]] <- NULL
  call_parameters[["num_strata"]] <- NULL
  call_parameters[["num_steps"]]  <- NULL

  do.call(nowcast, args = call_parameters)


}
