#' Preprocess the dates to create a covariate matrix
#'
#' @description
#' Takes a `data.frame` as generated by [preprocess_for_nowcast()] and generates a new `data.frame`
#' where the time covariates are codified for the model
#'
#' @param .disease_data A `data.frame` of cases as exported by [preprocess_for_nowcast()]
#' @param date The name of the date column in `.disease_data` to be used for the temporal effects
#' @param temporal_effects A `temporal_effects` object codifying the temporal effects to be used.
#'
#' @return A `data.frame` containing all of the case info
#'
#' @examples
#' #Get disease
#' disease_data <- preprocess_for_nowcast(denguedat, "onset_week", "report_week",
#'     units = "weeks", now = as.Date("1990-03-05"))
#' date_data    <- preprocess_dates(disease_data, date = "onset_week",
#'   temporal_effects = temporal_effects(week_of_year = TRUE))
#'
#' @export
preprocess_dates <- function(.disease_data, date, temporal_effects){

  #Get the column codifying the date
  date_data <- .disease_data |>
    dplyr::select(!!as.symbol(date))

  #Get the initial date (this is for codifying the month and epiweek effects so that they start in 1)
  init_date <- date_data |>
    dplyr::slice_head(n = 1) |>
    dplyr::pull(!!as.symbol(date))

  #Add day of the week effect-----
  if (temporal_effects[["day_of_week"]]){
    date_data <- date_data |>
      dplyr::mutate(!!as.symbol("day_of_week") := lubridate::wday(!!as.symbol(date)))
  }

  #Add weekend effect-----
  if (temporal_effects[["weekend"]]){
    date_data <- date_data |>
      dplyr::mutate(!!as.symbol("weekend") := as.numeric(!is_weekday(!!as.symbol(date))))
  }

  #Add day of the month effect-----
  if (temporal_effects[["day_of_month"]]){
    date_data <- date_data |>
      dplyr::mutate(!!as.symbol("day_of_month") := lubridate::day(!!as.symbol(date)))
  }

  #Add month effect (centered at current month = 1)-----
  if (temporal_effects[["month_of_year"]]){
    date_data <- date_data |>
      dplyr::mutate(!!as.symbol("month_of_year") := ((lubridate::month(!!as.symbol(date)) - lubridate::month(init_date)) %% 12) + 1)
  }

  #Add epiweek effect (centered at current week = 1 | week 53 that almost never happens is collapsed to January)-----
  if (temporal_effects[["week_of_year"]]){
    date_data <- date_data |>
      dplyr::mutate(!!as.symbol("week_of_year") := ((lubridate::epiweek(!!as.symbol(date)) - lubridate::epiweek(init_date)) %% 52) + 1)
  }

  #Add holiday effect-----
  if (!is.null(temporal_effects[["holidays"]])){

    #Check almanac installation
    if (!requireNamespace("almanac", quietly = TRUE)){
      cli::cli_abort(
        "Please install the `almanac` package to be able to integrate `holiday` effects"
      )
    } else {
      date_data <- date_data |>
        dplyr::mutate(!!as.symbol("holiday") := almanac::alma_in(!!as.symbol(date), temporal_effects[["holidays"]]))
    }
  }

  #Remove the date column
  date_data <- date_data |>
    dplyr::select(-!!as.symbol(date))

  return(date_data)

}

#' Check whether the date column is in the date data
#'
#' @param .date_data A data frame
#' @param .colname Column to check whether it is or isn't in date data
#'
#' @return Either true or false whether `.colname` is in `.date_data`.
#' @keywords internal
has_date <- function(.date_data, .colname){
  as.numeric(.colname %in% colnames(.date_data))
}

#' Get the date column if column is in the data.
#'
#' @param .date_data A data frame
#' @param .colname Column to check whether it is or isn't in date data
#'
#' @return The column `.colname` if it is a column; or an empty vector.
#' @keywords internal
datecol <- function(.date_data, .colname){
  if (.colname %in% colnames(.date_data)){
    vecval <- .date_data |> dplyr::pull(!!as.symbol(.colname)) |> as.vector()
  } else {
    vecval <- vector("numeric",length = 0)
  }
  return(vecval)
}
